/* automatically generated by rust-bindgen 0.59.2 */

pub const BOLOS_VERSION: &[u8; 6usize] = b"1.0.0\0";
pub const IO_SEPROXYHAL_BUFFER_SIZE_B: u32 = 300;
pub const BAGL_WIDTH: u32 = 128;
pub const BAGL_HEIGHT: u32 = 64;
pub const IO_USB_MAX_ENDPOINTS: u32 = 7;
pub const IO_HID_EP_LENGTH: u32 = 64;
pub const USB_SEGMENT_SIZE: u32 = 64;
pub const WEBUSB_URL_SIZE_B: u32 = 0;
pub const WEBUSB_URL: &[u8; 1usize] = b"\0";
pub const BAGL_NOFILL: u32 = 0;
pub const BAGL_FILL: u32 = 1;
pub const BAGL_OUTLINE: u32 = 2;
pub const BAGL_NOICON: u32 = 3;
pub const BAGL_FILL_CIRCLE_1_OCTANT: u32 = 1;
pub const BAGL_FILL_CIRCLE_2_OCTANT: u32 = 2;
pub const BAGL_FILL_CIRCLE_3_OCTANT: u32 = 4;
pub const BAGL_FILL_CIRCLE_4_OCTANT: u32 = 8;
pub const BAGL_FILL_CIRCLE_5_OCTANT: u32 = 16;
pub const BAGL_FILL_CIRCLE_6_OCTANT: u32 = 32;
pub const BAGL_FILL_CIRCLE_7_OCTANT: u32 = 64;
pub const BAGL_FILL_CIRCLE_8_OCTANT: u32 = 128;
pub const BAGL_FILL_CIRCLE: u32 = 255;
pub const BAGL_FILL_CIRCLE_3PI2_2PI: u32 = 3;
pub const BAGL_FILL_CIRCLE_PI_3PI2: u32 = 12;
pub const BAGL_FILL_CIRCLE_0_PI2: u32 = 48;
pub const BAGL_FILL_CIRCLE_PI2_PI: u32 = 192;
pub const BAGL_TYPE_FLAGS_MASK: u32 = 128;
pub const BAGL_FONT_ID_MASK: u32 = 4095;
pub const BAGL_FONT_ALIGNMENT_HORIZONTAL_MASK: u32 = 49152;
pub const BAGL_FONT_ALIGNMENT_LEFT: u32 = 0;
pub const BAGL_FONT_ALIGNMENT_RIGHT: u32 = 16384;
pub const BAGL_FONT_ALIGNMENT_CENTER: u32 = 32768;
pub const BAGL_FONT_ALIGNMENT_VERTICAL_MASK: u32 = 12288;
pub const BAGL_FONT_ALIGNMENT_TOP: u32 = 0;
pub const BAGL_FONT_ALIGNMENT_BOTTOM: u32 = 4096;
pub const BAGL_FONT_ALIGNMENT_MIDDLE: u32 = 8192;
pub const BAGL_STROKE_FLAG_ONESHOT: u32 = 128;
pub const BAGL_ENCODING_LATIN1: u32 = 0;
pub const BAGL_FONT_SYMBOLS_0_CLEAR: [u8; 2usize] = [128u8, 0u8];
pub const BAGL_FONT_SYMBOLS_0_DOT: [u8; 2usize] = [129u8, 0u8];
pub const BAGL_FONT_SYMBOLS_0_LEFT: [u8; 2usize] = [130u8, 0u8];
pub const BAGL_FONT_SYMBOLS_0_LIGHTNING: [u8; 2usize] = [131u8, 0u8];
pub const BAGL_FONT_SYMBOLS_0_MINIRIGHT: [u8; 2usize] = [132u8, 0u8];
pub const BAGL_FONT_SYMBOLS_0_DASHBOARD: [u8; 2usize] = [133u8, 0u8];
pub const BAGL_FONT_SYMBOLS_0_SETTINGS: [u8; 2usize] = [134u8, 0u8];
pub const BAGL_FONT_SYMBOLS_0_EXIT: [u8; 2usize] = [135u8, 0u8];
pub const BAGL_FONT_SYMBOLS_1_CARET: [u8; 2usize] = [160u8, 0u8];
pub const TARGET_ID: u32 = 856686596;
pub const IMPL_IO_APDU_BUFFER_SIZE: u32 = 260;
pub const IO_APDU_BUFFER_SIZE: u32 = 260;
pub const CHANNEL_APDU: u32 = 0;
pub const CHANNEL_KEYBOARD: u32 = 1;
pub const CHANNEL_SPI: u32 = 2;
pub const IO_RESET_AFTER_REPLIED: u32 = 128;
pub const IO_RECEIVE_DATA: u32 = 64;
pub const IO_RETURN_AFTER_TX: u32 = 32;
pub const IO_ASYNCH_REPLY: u32 = 16;
pub const IO_FINISHED: u32 = 8;
pub const IO_FLAGS: u32 = 248;
pub const BLE_SEGMENT_SIZE: u32 = 64;
pub const __NEWLIB_H__: u32 = 1;
pub const _NEWLIB_VERSION_H__: u32 = 1;
pub const _NEWLIB_VERSION: &[u8; 6usize] = b"3.3.0\0";
pub const __NEWLIB__: u32 = 3;
pub const __NEWLIB_MINOR__: u32 = 3;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const _WANT_IO_C99_FORMATS: u32 = 1;
pub const _WANT_IO_LONG_LONG: u32 = 1;
pub const _WANT_REGISTER_FINI: u32 = 1;
pub const _REENT_CHECK_VERIFY: u32 = 1;
pub const _MB_LEN_MAX: u32 = 1;
pub const HAVE_INITFINI_ARRAY: u32 = 1;
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _LDBL_EQ_DBL: u32 = 1;
pub const _FVWRITE_IN_STREAMIO: u32 = 1;
pub const _FSEEK_OPTIMIZATION: u32 = 1;
pub const _WIDE_ORIENT: u32 = 1;
pub const _UNBUF_STREAM_OPT: u32 = 1;
pub const _RETARGETABLE_LOCKING: u32 = 1;
pub const __OBSOLETE_MATH_DEFAULT: u32 = 1;
pub const __OBSOLETE_MATH: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const __RAND_MAX: u32 = 2147483647;
pub const __have_longlong64: u32 = 1;
pub const __have_long32: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___OFFSETOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _NULL: u32 = 0;
pub const _ATEXIT_SIZE: u32 = 32;
pub const _RAND48_SEED_0: u32 = 13070;
pub const _RAND48_SEED_1: u32 = 43981;
pub const _RAND48_SEED_2: u32 = 4660;
pub const _RAND48_MULT_0: u32 = 58989;
pub const _RAND48_MULT_1: u32 = 57068;
pub const _RAND48_MULT_2: u32 = 5;
pub const _RAND48_ADD: u32 = 11;
pub const _REENT_EMERGENCY_SIZE: u32 = 25;
pub const _REENT_ASCTIME_SIZE: u32 = 26;
pub const _REENT_SIGNAL_SIZE: u32 = 24;
pub const _N_LISTS: u32 = 30;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const _LITTLE_ENDIAN: u32 = 1234;
pub const _BIG_ENDIAN: u32 = 4321;
pub const _PDP_ENDIAN: u32 = 3412;
pub const _BYTE_ORDER: u32 = 1234;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const FD_SETSIZE: u32 = 64;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const PTHREAD_SCOPE_PROCESS: u32 = 0;
pub const PTHREAD_SCOPE_SYSTEM: u32 = 1;
pub const PTHREAD_INHERIT_SCHED: u32 = 1;
pub const PTHREAD_EXPLICIT_SCHED: u32 = 2;
pub const PTHREAD_CREATE_DETACHED: u32 = 0;
pub const PTHREAD_CREATE_JOINABLE: u32 = 1;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SORD: u32 = 8192;
pub const __SL64: u32 = 32768;
pub const __SNLK: u32 = 1;
pub const __SWID: u32 = 8192;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const EOF: i32 = -1;
pub const BUFSIZ: u32 = 1024;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const L_tmpnam: u32 = 1024;
pub const P_tmpdir: &[u8; 5usize] = b"/tmp\0";
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const TMP_MAX: u32 = 26;
pub const L_ctermid: u32 = 16;
pub const BOLOS_TRUE: u32 = 170;
pub const BOLOS_FALSE: u32 = 85;
pub const BOLOS_UX_OK: u32 = 170;
pub const BOLOS_UX_CANCEL: u32 = 85;
pub const BOLOS_UX_ERROR: u32 = 214;
pub const BOLOS_UX_IGNORE: u32 = 151;
pub const BOLOS_UX_REDRAW: u32 = 105;
pub const BOLOS_UX_CONTINUE: u32 = 0;
pub const BOLOS_APPNAME_MAX_SIZE_B: u32 = 32;
pub const BOLOS_APPVERSION_MAX_SIZE_B: u32 = 16;
pub const BOLOS_TAG_APPNAME: u32 = 1;
pub const BOLOS_TAG_APPVERSION: u32 = 2;
pub const BOLOS_TAG_ICON: u32 = 3;
pub const BOLOS_TAG_DERIVEPATH: u32 = 4;
pub const BOLOS_TAG_DATA_SIZE: u32 = 5;
pub const BOLOS_TAG_DEPENDENCY: u32 = 6;
pub const BOLOS_TAG_USER_TAG: u32 = 32;
pub const __int20: u32 = 2;
pub const __int20__: u32 = 2;
pub const __INT8: &[u8; 3usize] = b"hh\0";
pub const __INT16: &[u8; 2usize] = b"h\0";
pub const __INT64: &[u8; 3usize] = b"ll\0";
pub const __FAST8: &[u8; 3usize] = b"hh\0";
pub const __FAST16: &[u8; 2usize] = b"h\0";
pub const __FAST64: &[u8; 3usize] = b"ll\0";
pub const __LEAST8: &[u8; 3usize] = b"hh\0";
pub const __LEAST16: &[u8; 2usize] = b"h\0";
pub const __LEAST64: &[u8; 3usize] = b"ll\0";
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const BLE_CMD_APDU: u32 = 5;
pub const BLE_CHUNK_LENGTH: u32 = 20;
pub const M24SR_CHUNK_LENGTH: u32 = 246;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT: u32 = 1;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_REQBLE: u32 = 1;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_RECOVERY: u32 = 2;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FLASHBACK: u32 = 4;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_USB: u32 = 1;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_BLE: u32 = 2;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_TOUCH: u32 = 4;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_BUTTON_COUNT: u32 = 240;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_BUTTON_COUNT_POS: u32 = 4;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_SCREEN_MASK: u32 = 3840;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_NO_SCREEN: u32 = 0;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_SCREEN_BIG: u32 = 256;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_SCREEN_SML: u32 = 512;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_SCREEN_SSD1312: u32 = 768;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_LEDRGB: u32 = 4096;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_BATTERY: u32 = 8;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_ISET_MASK: u32 = 4026531840;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_ISET_BASIC: u32 = 0;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_ISET_MCUSEC: u32 = 268435456;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_ISET_MCUBL: u32 = 536870912;
pub const SEPROXYHAL_TAG_BLE_SECURITY_DB_EVENT: u32 = 2;
pub const SEPROXYHAL_TAG_BLE_SECURITY_DB_LOADED_EVENT: u32 = 0;
pub const SEPROXYHAL_TAG_BLE_SECURITY_DB_DUMP_EVENT: u32 = 1;
pub const SEPROXYHAL_TAG_BLE_WRITE_REQUEST_EVENT: u32 = 3;
pub const SEPROXYHAL_TAG_BLE_READ_REQUEST_EVENT: u32 = 4;
pub const SEPROXYHAL_TAG_BUTTON_PUSH_EVENT: u32 = 5;
pub const SEPROXYHAL_TAG_BUTTON_PUSH_ID_MASK: u32 = 254;
pub const SEPROXYHAL_TAG_BUTTON_PUSH_INTERVAL_MS: u32 = 100;
pub const SEPROXYHAL_TAG_NFC_FIELD_DETECTION_EVENT: u32 = 6;
pub const SEPROXYHAL_TAG_NFC_APDU_RECEIVED_EVENT: u32 = 7;
pub const SEPROXYHAL_TAG_BATTERY_NOTIFICATION_EVENT: u32 = 8;
pub const SEPROXYHAL_TAG_M24SR_GPO_CHANGE_EVENT: u32 = 9;
pub const SEPROXYHAL_TAG_M24SR_RESPONSE_APDU_EVENT: u32 = 10;
pub const SEPROXYHAL_TAG_BLE_NOTIFY_INDICATE_EVENT: u32 = 11;
pub const SEPROXYHAL_TAG_FINGER_EVENT: u32 = 12;
pub const SEPROXYHAL_TAG_FINGER_EVENT_TOUCH: u32 = 1;
pub const SEPROXYHAL_TAG_FINGER_EVENT_RELEASE: u32 = 2;
pub const SEPROXYHAL_TAG_DISPLAY_PROCESSED_EVENT: u32 = 13;
pub const SEPROXYHAL_TAG_TICKER_EVENT: u32 = 14;
pub const SEPROXYHAL_TAG_USB_EVENT: u32 = 15;
pub const SEPROXYHAL_TAG_USB_EVENT_RESET: u32 = 1;
pub const SEPROXYHAL_TAG_USB_EVENT_SOF: u32 = 2;
pub const SEPROXYHAL_TAG_USB_EVENT_SUSPENDED: u32 = 4;
pub const SEPROXYHAL_TAG_USB_EVENT_RESUMED: u32 = 8;
pub const SEPROXYHAL_TAG_USB_EP_XFER_EVENT: u32 = 16;
pub const SEPROXYHAL_TAG_USB_EP_XFER_SETUP: u32 = 1;
pub const SEPROXYHAL_TAG_USB_EP_XFER_IN: u32 = 2;
pub const SEPROXYHAL_TAG_USB_EP_XFER_OUT: u32 = 4;
pub const SEPROXYHAL_TAG_BLE_CONNECTION_EVENT: u32 = 17;
pub const SEPROXYHAL_TAG_UNSEC_CHUNK_EVENT: u32 = 18;
pub const SEPROXYHAL_TAG_ACK_LINK_SPEED: u32 = 19;
pub const SEPROXYHAL_TAG_BLUENRG_RECV_EVENT: u32 = 20;
pub const SEPROXYHAL_TAG_STATUS_EVENT: u32 = 21;
pub const SEPROXYHAL_TAG_STATUS_EVENT_FLAG_CHARGING: u32 = 1;
pub const SEPROXYHAL_TAG_STATUS_EVENT_FLAG_USB_ON: u32 = 2;
pub const SEPROXYHAL_TAG_STATUS_EVENT_FLAG_BLE_ON: u32 = 4;
pub const SEPROXYHAL_TAG_STATUS_EVENT_FLAG_USB_POWERED: u32 = 8;
pub const SEPROXYHAL_TAG_STATUS_EVENT_FLAG_CHARGING_ISSUE: u32 = 16;
pub const SEPROXYHAL_TAG_STATUS_EVENT_FLAG_TEMPERATURE_ISSUE: u32 = 32;
pub const SEPROXYHAL_TAG_STATUS_EVENT_FLAG_BATTERY_ISSUE: u32 = 64;
pub const SEPROXYHAL_TAG_CAPDU_EVENT: u32 = 22;
pub const SEPROXYHAL_TAG_I2C_EVENT: u32 = 23;
pub const SEPROXYHAL_TAG_I2C_EVENT_KIND_READ: u32 = 1;
pub const SEPROXYHAL_TAG_I2C_EVENT_KIND_WRITE: u32 = 2;
pub const SEPROXYHAL_TAG_BLE_RECV_EVENT: u32 = 24;
pub const SEPROXYHAL_TAG_BOOTLOADER_RAPDU_EVENT: u32 = 25;
pub const SEPROXYHAL_TAG_UX_EVENT: u32 = 26;
pub const SEPROXYHAL_TAG_UNSEC_CHUNK_READ: u32 = 50;
pub const SEPROXYHAL_TAG_UNSEC_CHUNK_READ_EXT: u32 = 51;
pub const SEPROXYHAL_TAG_BLE_SEND: u32 = 56;
pub const SEPROXYHAL_TAG_SET_SCREEN_CONFIG: u32 = 62;
pub const SEPROXYHAL_TAG_SET_LINK_PROP: u32 = 63;
pub const SEPROXYHAL_TAG_BLUENRG_SEND: u32 = 64;
pub const SEPROXYHAL_TAG_BLE_DEFINE_GENERIC_SETTING: u32 = 65;
pub const SEPROXYHAL_TAG_BLE_DEFINE_SERVICE_SETTING: u32 = 66;
pub const SEPROXYHAL_TAG_NFC_DEFINE_SERVICE_SETTING: u32 = 67;
pub const SEPROXYHAL_TAG_BLE_RADIO_POWER: u32 = 68;
pub const SEPROXYHAL_TAG_BLE_RADIO_POWER_ACTION_ON: u32 = 2;
pub const SEPROXYHAL_TAG_BLE_RADIO_POWER_ACTION_DBWIPE: u32 = 4;
pub const SEPROXYHAL_TAG_BLE_RADIO_POWER_FACTORY_TEST: u32 = 64;
pub const SEPROXYHAL_TAG_NFC_RADIO_POWER: u32 = 69;
pub const SEPROXYHAL_TAG_SE_POWER_OFF: u32 = 70;
pub const SEPROXYHAL_TAG_BLE_SECURITY_DB: u32 = 72;
pub const SEPROXYHAL_TAG_BLE_SECURITY_DB_CMD_READ: u32 = 1;
pub const SEPROXYHAL_TAG_BLE_SECURITY_DB_CMD_WRITE: u32 = 2;
pub const SEPROXYHAL_TAG_BATTERY_CHARGE: u32 = 73;
pub const SEPROXYHAL_TAG_DEVICE_OFF: u32 = 75;
pub const SEPROXYHAL_TAG_MORE_TIME: u32 = 76;
pub const SEPROXYHAL_TAG_M24SR_C_APDU: u32 = 77;
pub const SEPROXYHAL_TAG_SET_TICKER_INTERVAL: u32 = 78;
pub const SEPROXYHAL_TAG_USB_CONFIG: u32 = 79;
pub const SEPROXYHAL_TAG_USB_CONFIG_CONNECT: u32 = 1;
pub const SEPROXYHAL_TAG_USB_CONFIG_DISCONNECT: u32 = 2;
pub const SEPROXYHAL_TAG_USB_CONFIG_ADDR: u32 = 3;
pub const SEPROXYHAL_TAG_USB_CONFIG_ENDPOINTS: u32 = 4;
pub const SEPROXYHAL_TAG_USB_CONFIG_TYPE_DISABLED: u32 = 0;
pub const SEPROXYHAL_TAG_USB_CONFIG_TYPE_CONTROL: u32 = 1;
pub const SEPROXYHAL_TAG_USB_CONFIG_TYPE_INTERRUPT: u32 = 2;
pub const SEPROXYHAL_TAG_USB_CONFIG_TYPE_BULK: u32 = 3;
pub const SEPROXYHAL_TAG_USB_CONFIG_TYPE_ISOCHRONOUS: u32 = 4;
pub const SEPROXYHAL_TAG_USB_EP_PREPARE: u32 = 80;
pub const SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_SETUP: u32 = 16;
pub const SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_IN: u32 = 32;
pub const SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_OUT: u32 = 48;
pub const SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_STALL: u32 = 64;
pub const SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_UNSTALL: u32 = 128;
pub const SEPROXYHAL_TAG_SET_LED: u32 = 81;
pub const SEPROXYHAL_TAG_REQUEST_STATUS: u32 = 82;
pub const SEPROXYHAL_TAG_RAPDU: u32 = 83;
pub const SEPROXYHAL_TAG_I2C_XFER: u32 = 84;
pub const SEPROXYHAL_TAG_UX_CMD: u32 = 93;
pub const SEPROXYHAL_TAG_UX_CMD_BLE_DISABLE_ADV: u32 = 0;
pub const SEPROXYHAL_TAG_UX_CMD_BLE_ENABLE_ADV: u32 = 1;
pub const SEPROXYHAL_TAG_UX_CMD_BLE_RESET_PAIRINGS: u32 = 2;
pub const SEPROXYHAL_TAG_UX_CMD_REDISPLAY: u32 = 3;
pub const SEPROXYHAL_TAG_PRINTF: u32 = 95;
pub const SEPROXYHAL_TAG_DBG_SCREEN_DISPLAY_STATUS: u32 = 94;
pub const SEPROXYHAL_TAG_STATUS_MASK: u32 = 96;
pub const SEPROXYHAL_TAG_GENERAL_STATUS: u32 = 96;
pub const SEPROXYHAL_TAG_GENERAL_STATUS_LAST_COMMAND: u32 = 0;
pub const SEPROXYHAL_TAG_PAIRING_STATUS: u32 = 97;
pub const SEPROXYHAL_TAG_BLE_READ_RESPONSE_STATUS: u32 = 98;
pub const SEPROXYHAL_TAG_NFC_READ_RESPONSE_STATUS: u32 = 99;
pub const SEPROXYHAL_TAG_BLE_NOTIFY_INDICATE_STATUS: u32 = 100;
pub const SEPROXYHAL_TAG_SCREEN_DISPLAY_STATUS: u32 = 101;
pub const SEPROXYHAL_TAG_PRINTF_STATUS: u32 = 102;
pub const SEPROXYHAL_TAG_SET_LINK_SPEED: u32 = 103;
pub const SEPROXYHAL_TAG_SCREEN_ANIMATION_STATUS: u32 = 104;
pub const SEPROXYHAL_TAG_SCREEN_ANIMATION_STATUS_VERTICAL_SPLIT_SLIDE: u32 = 0;
pub const SEPROXYHAL_TAG_BOOTLOADER_CAPDU_STATUS: u32 = 106;
pub const IO_CACHE: u32 = 1;
pub const NO_TIMEOUT: u32 = 0;
pub const ENDORSEMENT_MAX_ASN1_LENGTH: u32 = 72;
pub const OS_PARSE_BERTLV_OFFSET_COMPARE_WITH_BUFFER: u32 = 2147483648;
pub const OS_PARSE_BERTLV_OFFSET_GET_LENGTH: u32 = 1073741824;
pub const APPLICATION_FLAG_MAIN: u32 = 1;
pub const APPLICATION_FLAG_BOLOS_UPGRADE: u32 = 2;
pub const APPLICATION_FLAG_SIGNED: u32 = 4;
pub const APPLICATION_FLAG_BOLOS_UX: u32 = 8;
pub const APPLICATION_FLAG_DERIVE_MASTER: u32 = 16;
pub const APPLICATION_FLAG_SHARED_NVRAM: u32 = 32;
pub const APPLICATION_FLAG_GLOBAL_PIN: u32 = 64;
pub const APPLICATION_FLAG_DEBUG: u32 = 128;
pub const APPLICATION_FLAG_AUTOBOOT: u32 = 256;
pub const APPLICATION_FLAG_BOLOS_SETTINGS: u32 = 512;
pub const APPLICATION_FLAG_CUSTOM_CA: u32 = 1024;
pub const APPLICATION_FLAG_LIBRARY: u32 = 2048;
pub const APPLICATION_FLAG_NO_RUN: u32 = 4096;
pub const APPLICATION_FLAG_ISSUER: u32 = 16384;
pub const APPLICATION_FLAG_ENABLED: u32 = 32768;
pub const APPLICATION_FLAG_AEM_PIN: u32 = 8;
pub const APPLICATION_FLAG_NEG_MASK: u32 = 4294901760;
pub const OS_FLAG_RECOVERY: u32 = 1;
pub const OS_FLAG_SIGNED_MCU_CODE: u32 = 2;
pub const OS_FLAG_ONBOARDED: u32 = 4;
pub const OS_FLAG_PIN_VALIDATED: u32 = 128;
pub const NVM_ERASED_WORD_VALUE: u32 = 4294967295;
pub const DEFAULT_PIN_RETRIES: u32 = 3;
pub const CX_OK: u32 = 0;
pub const CX_CARRY: u32 = 4294967073;
pub const CX_LOCKED: u32 = 4294967169;
pub const CX_UNLOCKED: u32 = 4294967170;
pub const CX_NOT_LOCKED: u32 = 4294967171;
pub const CX_NOT_UNLOCKED: u32 = 4294967172;
pub const CX_INTERNAL_ERROR: u32 = 4294967173;
pub const CX_INVALID_PARAMETER_SIZE: u32 = 4294967174;
pub const CX_INVALID_PARAMETER_VALUE: u32 = 4294967175;
pub const CX_INVALID_PARAMETER: u32 = 4294967176;
pub const CX_NOT_INVERTIBLE: u32 = 4294967177;
pub const CX_OVERFLOW: u32 = 4294967178;
pub const CX_MEMORY_FULL: u32 = 4294967179;
pub const CX_NO_RESIDUE: u32 = 4294967180;
pub const CX_EC_INFINITE_POINT: u32 = 4294967105;
pub const CX_EC_INVALID_POINT: u32 = 4294967202;
pub const CX_EC_INVALID_CURVE: u32 = 4294967203;
pub const OS_REGISTRY_GET_TAG_OFFSET_COMPARE_WITH_BUFFER: u32 = 2147483648;
pub const OS_REGISTRY_GET_TAG_OFFSET_GET_LENGTH: u32 = 1073741824;
pub const ERR_IOL_RANGE: u32 = 4096;
pub const ERR_TSK_RANGE: u32 = 8192;
pub const ERR_CRY_RANGE: u32 = 12288;
pub const ERR_PAR_RANGE: u32 = 16384;
pub const ERR_SEC_RANGE: u32 = 20480;
pub const ERR_APD_RANGE: u32 = 24576;
pub const ERR_MUI_RANGE: u32 = 40960;
pub const ERR_APP_RANGE_01: u32 = 45056;
pub const ERR_APP_RANGE_02: u32 = 49152;
pub const ERR_APP_RANGE_03: u32 = 53248;
pub const ERR_APP_RANGE_04: u32 = 57344;
pub const ERR_GEN_SUB_01: u32 = 256;
pub const ERR_GEN_SUB_02: u32 = 512;
pub const ERR_GEN_SUB_03: u32 = 768;
pub const ERR_GEN_SUB_04: u32 = 1024;
pub const ERR_GEN_SUB_05: u32 = 1280;
pub const ERR_GEN_SUB_06: u32 = 1536;
pub const ERR_GEN_SUB_07: u32 = 1792;
pub const ERR_GEN_SUB_08: u32 = 2048;
pub const ERR_GEN_SUB_09: u32 = 2304;
pub const ERR_GEN_SUB_0D: u32 = 3328;
pub const ERR_GEN_SUB_0E: u32 = 3584;
pub const ERR_IOL_OFW: u32 = 4352;
pub const ERR_IOL_HDR: u32 = 4608;
pub const ERR_IOL_STA: u32 = 4864;
pub const ERR_IOL_RST: u32 = 5120;
pub const ERR_TSK_STC: u32 = 8448;
pub const ERR_TSK_OWN: u32 = 8704;
pub const ERR_TSK_OFW: u32 = 8960;
pub const ERR_CRY_LEN: u32 = 12544;
pub const ERR_CRY_VAL: u32 = 12800;
pub const ERR_PAR_LEN: u32 = 16640;
pub const ERR_PAR_VAL: u32 = 16896;
pub const ERR_SEC_APP: u32 = 20736;
pub const ERR_SEC_CRC: u32 = 20992;
pub const ERR_SEC_CHK: u32 = 21248;
pub const ERR_SEC_KEY: u32 = 21504;
pub const ERR_SEC_PIN: u32 = 21760;
pub const ERR_SEC_SCP: u32 = 22016;
pub const ERR_SEC_SIG: u32 = 22272;
pub const ERR_SEC_MEM: u32 = 22528;
pub const ERR_SEC_STA: u32 = 22784;
pub const ERR_APD_CLA: u32 = 28160;
pub const ERR_APD_INS: u32 = 27904;
pub const ERR_APD_HDR: u32 = 25856;
pub const ERR_APD_STA: u32 = 26112;
pub const ERR_APD_LEN: u32 = 26368;
pub const ERR_APD_DAT: u32 = 26624;
pub const SWO_SUCCESS: u32 = 36864;
pub const EXCEPTION: u32 = 1;
pub const INVALID_PARAMETER: u32 = 2;
pub const EXCEPTION_SECURITY: u32 = 3;
pub const INVALID_STATE: u32 = 4;
pub const EXCEPTION_IO_RESET: u32 = 5;
pub const NOT_ENOUGH_SPACE: u32 = 6;
pub const EXCEPTION_OVERFLOW: u32 = 7;
pub const INVALID_CRC: u32 = 8;
pub const INVALID_CHECKSUM: u32 = 9;
pub const INVALID_COUNTER: u32 = 10;
pub const NOT_SUPPORTED: u32 = 11;
pub const TIMEOUT: u32 = 12;
pub const EXCEPTION_PIC: u32 = 13;
pub const EXCEPTION_APPEXIT: u32 = 14;
pub const EXCEPTION_IO_OVERFLOW: u32 = 15;
pub const EXCEPTION_IO_HEADER: u32 = 16;
pub const EXCEPTION_IO_STATE: u32 = 17;
pub const EXCEPTION_CXPORT: u32 = 18;
pub const EXCEPTION_SYSTEM: u32 = 19;
pub const CX_LAST: u32 = 1;
pub const CX_SIG_MODE: u32 = 2;
pub const CX_MASK_SIGCRYPT: u32 = 6;
pub const CX_ENCRYPT: u32 = 4;
pub const CX_DECRYPT: u32 = 0;
pub const CX_SIGN: u32 = 6;
pub const CX_VERIFY: u32 = 2;
pub const CX_MASK_PAD: u32 = 56;
pub const CX_PAD_NONE: u32 = 0;
pub const CX_PAD_ISO9797M1: u32 = 8;
pub const CX_PAD_ISO9797M2: u32 = 16;
pub const CX_PAD_PKCS1_1o5: u32 = 24;
pub const CX_PAD_PKCS1_PSS: u32 = 32;
pub const CX_PAD_PKCS1_OAEP: u32 = 40;
pub const CX_MASK_CHAIN: u32 = 448;
pub const CX_CHAIN_ECB: u32 = 0;
pub const CX_CHAIN_CBC: u32 = 64;
pub const CX_CHAIN_CTR: u32 = 128;
pub const CX_CHAIN_CFB: u32 = 192;
pub const CX_CHAIN_OFB: u32 = 256;
pub const CX_MASK_ECC_VARIANT: u32 = 448;
pub const CX_NO_CANONICAL: u32 = 64;
pub const CX_MASK_RND: u32 = 3584;
pub const CX_RND_PRNG: u32 = 512;
pub const CX_RND_TRNG: u32 = 1024;
pub const CX_RND_RFC6979: u32 = 1536;
pub const CX_RND_PROVIDED: u32 = 2048;
pub const CX_MASK_EC: u32 = 28672;
pub const CX_ECSCHNORR_BIP0340: u32 = 0;
pub const CX_ECDH_POINT: u32 = 4096;
pub const CX_ECDH_X: u32 = 8192;
pub const CX_ECSCHNORR_ISO14888_XY: u32 = 12288;
pub const CX_ECSCHNORR_ISO14888_X: u32 = 16384;
pub const CX_ECSCHNORR_BSI03111: u32 = 20480;
pub const CX_ECSCHNORR_LIBSECP: u32 = 24576;
pub const CX_ECSCHNORR_Z: u32 = 28672;
pub const CX_NO_REINIT: u32 = 32768;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const CX_HASH_MAX_BLOCK_COUNT: u32 = 65535;
pub const CX_BN_WORD_ALIGNEMENT: u32 = 16;
pub const CX_BN_FLAG_UNSET: u32 = 128;
pub const CX_MAX_DOMAIN_LENGTH: u32 = 66;
pub const CX_ECCINFO_PARITY_ODD: u32 = 1;
pub const CX_ECCINFO_xGTn: u32 = 2;
pub const BOLOS_UX_ONBOARDING_ALGORITHM_BIP39: u32 = 1;
pub const BOLOS_UX_ONBOARDING_ALGORITHM_ELECTRUM: u32 = 2;
pub const HDW_NORMAL: u32 = 0;
pub const HDW_ED25519_SLIP10: u32 = 1;
pub const HDW_SLIP21: u32 = 2;
pub const SYSCALL_get_api_level_ID: u32 = 1;
pub const SYSCALL_halt_ID: u32 = 2;
pub const SYSCALL_nvm_write_ID: u32 = 50331651;
pub const SYSCALL_nvm_erase_ID: u32 = 33554721;
pub const SYSCALL_cx_aes_set_key_hw_ID: u32 = 33554610;
pub const SYSCALL_cx_aes_reset_hw_ID: u32 = 179;
pub const SYSCALL_cx_aes_block_hw_ID: u32 = 33554612;
pub const SYSCALL_cx_des_set_key_hw_ID: u32 = 33554607;
pub const SYSCALL_cx_des_reset_hw_ID: u32 = 176;
pub const SYSCALL_cx_des_block_hw_ID: u32 = 33554609;
pub const SYSCALL_cx_bn_lock_ID: u32 = 33554706;
pub const SYSCALL_cx_bn_unlock_ID: u32 = 182;
pub const SYSCALL_cx_bn_is_locked_ID: u32 = 183;
pub const SYSCALL_cx_bn_alloc_ID: u32 = 33554707;
pub const SYSCALL_cx_bn_alloc_init_ID: u32 = 67109140;
pub const SYSCALL_cx_bn_destroy_ID: u32 = 16777404;
pub const SYSCALL_cx_bn_nbytes_ID: u32 = 33554701;
pub const SYSCALL_cx_bn_init_ID: u32 = 50331925;
pub const SYSCALL_cx_bn_rand_ID: u32 = 16777450;
pub const SYSCALL_cx_bn_copy_ID: u32 = 33554624;
pub const SYSCALL_cx_bn_set_u32_ID: u32 = 33554625;
pub const SYSCALL_cx_bn_get_u32_ID: u32 = 33554667;
pub const SYSCALL_cx_bn_export_ID: u32 = 50331843;
pub const SYSCALL_cx_bn_cmp_ID: u32 = 50331844;
pub const SYSCALL_cx_bn_cmp_u32_ID: u32 = 50331845;
pub const SYSCALL_cx_bn_is_odd_ID: u32 = 33554712;
pub const SYSCALL_cx_bn_xor_ID: u32 = 50331848;
pub const SYSCALL_cx_bn_or_ID: u32 = 50331849;
pub const SYSCALL_cx_bn_and_ID: u32 = 50331850;
pub const SYSCALL_cx_bn_tst_bit_ID: u32 = 50331851;
pub const SYSCALL_cx_bn_set_bit_ID: u32 = 33554636;
pub const SYSCALL_cx_bn_clr_bit_ID: u32 = 33554637;
pub const SYSCALL_cx_bn_shr_ID: u32 = 33554638;
pub const SYSCALL_cx_bn_shl_ID: u32 = 33554716;
pub const SYSCALL_cx_bn_cnt_bits_ID: u32 = 33554668;
pub const SYSCALL_cx_bn_add_ID: u32 = 50331929;
pub const SYSCALL_cx_bn_sub_ID: u32 = 50331930;
pub const SYSCALL_cx_bn_mul_ID: u32 = 50331858;
pub const SYSCALL_cx_bn_mod_add_ID: u32 = 67109075;
pub const SYSCALL_cx_bn_mod_sub_ID: u32 = 67109076;
pub const SYSCALL_cx_bn_mod_mul_ID: u32 = 67109077;
pub const SYSCALL_cx_bn_reduce_ID: u32 = 50331862;
pub const SYSCALL_cx_bn_mod_sqrt_ID: u32 = 67109149;
pub const SYSCALL_cx_bn_mod_pow_bn_ID: u32 = 67109079;
pub const SYSCALL_cx_bn_mod_pow_ID: u32 = 83886317;
pub const SYSCALL_cx_bn_mod_pow2_ID: u32 = 83886318;
pub const SYSCALL_cx_bn_mod_invert_nprime_ID: u32 = 50331866;
pub const SYSCALL_cx_bn_mod_u32_invert_ID: u32 = 50331926;
pub const SYSCALL_cx_bn_is_prime_ID: u32 = 33554671;
pub const SYSCALL_cx_bn_next_prime_ID: u32 = 16777456;
pub const SYSCALL_cx_bn_rng_ID: u32 = 33554909;
pub const SYSCALL_cx_bn_gf2_n_mul_ID: u32 = 83886150;
pub const SYSCALL_cx_mont_alloc_ID: u32 = 33554652;
pub const SYSCALL_cx_mont_init_ID: u32 = 33554653;
pub const SYSCALL_cx_mont_init2_ID: u32 = 50331870;
pub const SYSCALL_cx_mont_to_montgomery_ID: u32 = 50331871;
pub const SYSCALL_cx_mont_from_montgomery_ID: u32 = 50331872;
pub const SYSCALL_cx_mont_mul_ID: u32 = 67109089;
pub const SYSCALL_cx_mont_pow_ID: u32 = 83886306;
pub const SYSCALL_cx_mont_pow_bn_ID: u32 = 67109091;
pub const SYSCALL_cx_mont_invert_nprime_ID: u32 = 50331876;
pub const SYSCALL_cx_ecdomain_size_ID: u32 = 33554734;
pub const SYSCALL_cx_ecdomain_parameters_length_ID: u32 = 33554735;
pub const SYSCALL_cx_ecdomain_parameter_ID: u32 = 67109168;
pub const SYSCALL_cx_ecdomain_parameter_bn_ID: u32 = 50331953;
pub const SYSCALL_cx_ecdomain_generator_ID: u32 = 67109170;
pub const SYSCALL_cx_ecdomain_generator_bn_ID: u32 = 33554739;
pub const SYSCALL_cx_ecpoint_alloc_ID: u32 = 33554673;
pub const SYSCALL_cx_ecpoint_destroy_ID: u32 = 16777458;
pub const SYSCALL_cx_ecpoint_init_ID: u32 = 83886323;
pub const SYSCALL_cx_ecpoint_init_bn_ID: u32 = 50331892;
pub const SYSCALL_cx_ecpoint_export_ID: u32 = 83886325;
pub const SYSCALL_cx_ecpoint_export_bn_ID: u32 = 50331894;
pub const SYSCALL_cx_ecpoint_compress_ID: u32 = 67109164;
pub const SYSCALL_cx_ecpoint_decompress_ID: u32 = 67109165;
pub const SYSCALL_cx_ecpoint_add_ID: u32 = 50331918;
pub const SYSCALL_cx_ecpoint_neg_ID: u32 = 16777487;
pub const SYSCALL_cx_ecpoint_scalarmul_ID: u32 = 50331920;
pub const SYSCALL_cx_ecpoint_scalarmul_bn_ID: u32 = 33554705;
pub const SYSCALL_cx_ecpoint_rnd_scalarmul_ID: u32 = 50331943;
pub const SYSCALL_cx_ecpoint_rnd_scalarmul_bn_ID: u32 = 33554728;
pub const SYSCALL_cx_ecpoint_double_scalarmul_ID: u32 = 117440840;
pub const SYSCALL_cx_ecpoint_double_scalarmul_bn_ID: u32 = 83886410;
pub const SYSCALL_cx_ecpoint_cmp_ID: u32 = 50331899;
pub const SYSCALL_cx_ecpoint_is_on_curve_ID: u32 = 33554684;
pub const SYSCALL_cx_ecpoint_is_at_infinity_ID: u32 = 33554763;
pub const SYSCALL_cx_crc32_hw_ID: u32 = 33554690;
pub const SYSCALL_cx_get_random_bytes_ID: u32 = 33554695;
pub const SYSCALL_cx_trng_get_random_data_ID: u32 = 33554694;
pub const SYSCALL_os_perso_erase_all_ID: u32 = 75;
pub const SYSCALL_os_perso_set_seed_ID: u32 = 67108942;
pub const SYSCALL_os_perso_derive_and_set_seed_ID: u32 = 117440591;
pub const SYSCALL_os_perso_set_words_ID: u32 = 33554512;
pub const SYSCALL_os_perso_finalize_ID: u32 = 81;
pub const SYSCALL_os_perso_isonboarded_ID: u32 = 159;
pub const SYSCALL_os_perso_setonboardingstatus_ID: u32 = 67109012;
pub const SYSCALL_os_perso_derive_node_bip32_ID: u32 = 83886163;
pub const SYSCALL_os_perso_derive_node_with_seed_key_ID: u32 = 134217894;
pub const SYSCALL_os_perso_derive_eip2333_ID: u32 = 67109031;
pub const SYSCALL_os_endorsement_get_code_hash_ID: u32 = 16777301;
pub const SYSCALL_os_endorsement_get_public_key_ID: u32 = 33554518;
pub const SYSCALL_os_endorsement_get_public_key_certificate_ID: u32 = 33554519;
pub const SYSCALL_os_endorsement_key1_get_app_secret_ID: u32 = 16777304;
pub const SYSCALL_os_endorsement_key1_sign_data_ID: u32 = 50331737;
pub const SYSCALL_os_endorsement_key2_derive_sign_data_ID: u32 = 50331738;
pub const SYSCALL_os_perso_set_pin_ID: u32 = 50331724;
pub const SYSCALL_os_perso_set_current_identity_pin_ID: u32 = 33554509;
pub const SYSCALL_os_global_pin_is_validated_ID: u32 = 160;
pub const SYSCALL_os_global_pin_check_ID: u32 = 33554593;
pub const SYSCALL_os_global_pin_invalidate_ID: u32 = 93;
pub const SYSCALL_os_global_pin_retries_ID: u32 = 94;
pub const SYSCALL_os_registry_count_ID: u32 = 95;
pub const SYSCALL_os_registry_get_ID: u32 = 33554722;
pub const SYSCALL_os_ux_ID: u32 = 16777316;
pub const SYSCALL_os_ux_result_ID: u32 = 16777317;
pub const SYSCALL_os_lib_call_ID: u32 = 16777319;
pub const SYSCALL_os_lib_end_ID: u32 = 104;
pub const SYSCALL_os_flags_ID: u32 = 106;
pub const SYSCALL_os_version_ID: u32 = 33554539;
pub const SYSCALL_os_serial_ID: u32 = 33554540;
pub const SYSCALL_os_seph_features_ID: u32 = 110;
pub const SYSCALL_os_seph_version_ID: u32 = 33554543;
pub const SYSCALL_os_bootloader_version_ID: u32 = 33554547;
pub const SYSCALL_os_setting_get_ID: u32 = 50331760;
pub const SYSCALL_os_setting_set_ID: u32 = 50331761;
pub const SYSCALL_os_get_memory_info_ID: u32 = 16777330;
pub const SYSCALL_os_registry_get_tag_ID: u32 = 100663587;
pub const SYSCALL_os_registry_get_current_app_tag_ID: u32 = 50331764;
pub const SYSCALL_os_registry_delete_app_and_dependees_ID: u32 = 16777508;
pub const SYSCALL_os_registry_delete_all_apps_ID: u32 = 293;
pub const SYSCALL_os_sched_exec_ID: u32 = 16777510;
pub const SYSCALL_os_sched_exit_ID: u32 = 16777370;
pub const SYSCALL_os_sched_is_running_ID: u32 = 16777371;
pub const SYSCALL_os_sched_create_ID: u32 = 117440795;
pub const SYSCALL_os_sched_kill_ID: u32 = 16777336;
pub const SYSCALL_io_seph_send_ID: u32 = 33554563;
pub const SYSCALL_io_seph_is_status_sent_ID: u32 = 132;
pub const SYSCALL_io_seph_recv_ID: u32 = 50331781;
pub const SYSCALL_nvm_write_page_ID: u32 = 16777482;
pub const SYSCALL_nvm_erase_page_ID: u32 = 16777526;
pub const SYSCALL_try_context_get_ID: u32 = 135;
pub const SYSCALL_try_context_set_ID: u32 = 16777483;
pub const SYSCALL_os_sched_last_status_ID: u32 = 16777372;
pub const SYSCALL_os_sched_yield_ID: u32 = 16777373;
pub const SYSCALL_os_sched_switch_ID: u32 = 33554590;
pub const SYSCALL_os_sched_current_task_ID: u32 = 139;
pub const SYSCALL_os_allow_protected_flash_ID: u32 = 142;
pub const SYSCALL_os_deny_protected_flash_ID: u32 = 145;
pub const SYSCALL_os_allow_protected_ram_ID: u32 = 146;
pub const SYSCALL_os_deny_protected_ram_ID: u32 = 147;
pub const SYSCALL_os_customca_verify_ID: u32 = 50331792;
pub const CX_APILEVEL: u32 = 12;
pub const CX_COMPAT_APILEVEL: u32 = 12;
pub const CXPORT_ED_DES: u32 = 1;
pub const CXPORT_ED_AES: u32 = 2;
pub const CXPORT_ED_RSA: u32 = 4;
pub const CX_AES_BLOCK_SIZE: u32 = 16;
pub const CX_DES_BLOCK_SIZE: u32 = 8;
pub const CX_SHA256_SIZE: u32 = 32;
pub const CX_SHA384_SIZE: u32 = 48;
pub const CX_SHA512_SIZE: u32 = 64;
pub const bagl_components_type_e__BAGL_NONE: bagl_components_type_e_ = 0;
pub const bagl_components_type_e__BAGL_BUTTON: bagl_components_type_e_ = 1;
pub const bagl_components_type_e__BAGL_LABEL: bagl_components_type_e_ = 2;
pub const bagl_components_type_e__BAGL_RECTANGLE: bagl_components_type_e_ = 3;
pub const bagl_components_type_e__BAGL_LINE: bagl_components_type_e_ = 4;
pub const bagl_components_type_e__BAGL_ICON: bagl_components_type_e_ = 5;
pub const bagl_components_type_e__BAGL_CIRCLE: bagl_components_type_e_ = 6;
pub const bagl_components_type_e__BAGL_LABELINE: bagl_components_type_e_ = 7;
pub const bagl_components_type_e__BAGL_FLAG_TOUCHABLE: bagl_components_type_e_ = 128;
pub type bagl_components_type_e_ = cty::c_uint;
pub use self::bagl_components_type_e_ as bagl_components_type_e;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bagl_component_t {
    pub type_: bagl_components_type_e,
    pub userid: cty::c_uchar,
    pub x: cty::c_short,
    pub y: cty::c_short,
    pub width: cty::c_ushort,
    pub height: cty::c_ushort,
    pub stroke: cty::c_uchar,
    pub radius: cty::c_uchar,
    pub fill: cty::c_uchar,
    pub fgcolor: cty::c_uint,
    pub bgcolor: cty::c_uint,
    pub font_id: cty::c_ushort,
    pub icon_id: cty::c_uchar,
}
#[test]
fn bindgen_test_layout_bagl_component_t() {
    assert_eq!(
        ::core::mem::size_of::<bagl_component_t>(),
        32usize,
        concat!("Size of: ", stringify!(bagl_component_t))
    );
    assert_eq!(
        ::core::mem::align_of::<bagl_component_t>(),
        4usize,
        concat!("Alignment of ", stringify!(bagl_component_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_component_t>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_component_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_component_t>())).userid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_component_t),
            "::",
            stringify!(userid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_component_t>())).x as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_component_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_component_t>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_component_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_component_t>())).width as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_component_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_component_t>())).height as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_component_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_component_t>())).stroke as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_component_t),
            "::",
            stringify!(stroke)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_component_t>())).radius as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_component_t),
            "::",
            stringify!(radius)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_component_t>())).fill as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_component_t),
            "::",
            stringify!(fill)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_component_t>())).fgcolor as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_component_t),
            "::",
            stringify!(fgcolor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_component_t>())).bgcolor as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_component_t),
            "::",
            stringify!(bgcolor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_component_t>())).font_id as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_component_t),
            "::",
            stringify!(font_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_component_t>())).icon_id as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_component_t),
            "::",
            stringify!(icon_id)
        )
    );
}
impl Default for bagl_component_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " helper structure to help handling icons"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bagl_icon_details_s {
    pub width: cty::c_uint,
    pub height: cty::c_uint,
    pub bpp: cty::c_uint,
    pub colors: *const cty::c_uint,
    pub bitmap: *const cty::c_uchar,
}
#[test]
fn bindgen_test_layout_bagl_icon_details_s() {
    assert_eq!(
        ::core::mem::size_of::<bagl_icon_details_s>(),
        20usize,
        concat!("Size of: ", stringify!(bagl_icon_details_s))
    );
    assert_eq!(
        ::core::mem::align_of::<bagl_icon_details_s>(),
        4usize,
        concat!("Alignment of ", stringify!(bagl_icon_details_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_icon_details_s>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_icon_details_s),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_icon_details_s>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_icon_details_s),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_icon_details_s>())).bpp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_icon_details_s),
            "::",
            stringify!(bpp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_icon_details_s>())).colors as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_icon_details_s),
            "::",
            stringify!(colors)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_icon_details_s>())).bitmap as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_icon_details_s),
            "::",
            stringify!(bitmap)
        )
    );
}
impl Default for bagl_icon_details_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " helper structure to help handling icons"]
pub type bagl_icon_details_t = bagl_icon_details_s;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bagl_font_character_t {
    pub char_width: cty::c_uchar,
    pub bitmap_byte_count: cty::c_uchar,
    pub bitmap_offset: cty::c_ushort,
}
#[test]
fn bindgen_test_layout_bagl_font_character_t() {
    assert_eq!(
        ::core::mem::size_of::<bagl_font_character_t>(),
        4usize,
        concat!("Size of: ", stringify!(bagl_font_character_t))
    );
    assert_eq!(
        ::core::mem::align_of::<bagl_font_character_t>(),
        2usize,
        concat!("Alignment of ", stringify!(bagl_font_character_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bagl_font_character_t>())).char_width as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_font_character_t),
            "::",
            stringify!(char_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bagl_font_character_t>())).bitmap_byte_count as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_font_character_t),
            "::",
            stringify!(bitmap_byte_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bagl_font_character_t>())).bitmap_offset as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_font_character_t),
            "::",
            stringify!(bitmap_offset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bagl_font_t {
    pub font_id: cty::c_uint,
    pub bpp: cty::c_uchar,
    pub char_height: cty::c_uchar,
    pub baseline_height: cty::c_uchar,
    pub char_kerning: cty::c_uchar,
    pub first_char: cty::c_ushort,
    pub last_char: cty::c_ushort,
    pub characters: *const bagl_font_character_t,
    pub bitmap: *const cty::c_uchar,
}
#[test]
fn bindgen_test_layout_bagl_font_t() {
    assert_eq!(
        ::core::mem::size_of::<bagl_font_t>(),
        20usize,
        concat!("Size of: ", stringify!(bagl_font_t))
    );
    assert_eq!(
        ::core::mem::align_of::<bagl_font_t>(),
        4usize,
        concat!("Alignment of ", stringify!(bagl_font_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_font_t>())).font_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_font_t),
            "::",
            stringify!(font_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_font_t>())).bpp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_font_t),
            "::",
            stringify!(bpp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_font_t>())).char_height as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_font_t),
            "::",
            stringify!(char_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_font_t>())).baseline_height as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_font_t),
            "::",
            stringify!(baseline_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_font_t>())).char_kerning as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_font_t),
            "::",
            stringify!(char_kerning)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_font_t>())).first_char as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_font_t),
            "::",
            stringify!(first_char)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_font_t>())).last_char as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_font_t),
            "::",
            stringify!(last_char)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_font_t>())).characters as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_font_t),
            "::",
            stringify!(characters)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_font_t>())).bitmap as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_font_t),
            "::",
            stringify!(bitmap)
        )
    );
}
impl Default for bagl_font_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut C_bagl_fonts: [*const bagl_font_t; 0usize];
}
extern "C" {
    pub static C_bagl_fonts_count: cty::c_uint;
}
pub const bagl_font_id_e_BAGL_FONT_LUCIDA_CONSOLE_8PX: bagl_font_id_e = 0;
pub const bagl_font_id_e_BAGL_FONT_OPEN_SANS_LIGHT_16_22PX: bagl_font_id_e = 1;
pub const bagl_font_id_e_BAGL_FONT_OPEN_SANS_REGULAR_8_11PX: bagl_font_id_e = 2;
pub const bagl_font_id_e_BAGL_FONT_OPEN_SANS_REGULAR_10_13PX: bagl_font_id_e = 3;
pub const bagl_font_id_e_BAGL_FONT_OPEN_SANS_REGULAR_11_14PX: bagl_font_id_e = 4;
pub const bagl_font_id_e_BAGL_FONT_OPEN_SANS_REGULAR_13_18PX: bagl_font_id_e = 5;
pub const bagl_font_id_e_BAGL_FONT_OPEN_SANS_REGULAR_22_30PX: bagl_font_id_e = 6;
pub const bagl_font_id_e_BAGL_FONT_OPEN_SANS_SEMIBOLD_8_11PX: bagl_font_id_e = 7;
pub const bagl_font_id_e_BAGL_FONT_OPEN_SANS_EXTRABOLD_11px: bagl_font_id_e = 8;
pub const bagl_font_id_e_BAGL_FONT_OPEN_SANS_LIGHT_16px: bagl_font_id_e = 9;
pub const bagl_font_id_e_BAGL_FONT_OPEN_SANS_REGULAR_11px: bagl_font_id_e = 10;
pub const bagl_font_id_e_BAGL_FONT_OPEN_SANS_SEMIBOLD_10_13PX: bagl_font_id_e = 11;
pub const bagl_font_id_e_BAGL_FONT_OPEN_SANS_SEMIBOLD_11_16PX: bagl_font_id_e = 12;
pub const bagl_font_id_e_BAGL_FONT_OPEN_SANS_SEMIBOLD_13_18PX: bagl_font_id_e = 13;
pub const bagl_font_id_e_BAGL_FONT_SYMBOLS_0: bagl_font_id_e = 14;
pub const bagl_font_id_e_BAGL_FONT_SYMBOLS_1: bagl_font_id_e = 15;
pub const bagl_font_id_e_BAGL_FONT_LAST: bagl_font_id_e = 16;
pub type bagl_font_id_e = cty::c_uint;
pub const bagl_glyph_e_BAGL_GLYPH_NOGLYPH: bagl_glyph_e = 0;
pub const bagl_glyph_e_BAGL_GLYPH_LOGO_LEDGER_100: bagl_glyph_e = 1;
pub const bagl_glyph_e_BAGL_GLYPH_LOGO_LEDGER_BLUE_120: bagl_glyph_e = 2;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_GEARS_50: bagl_glyph_e = 3;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_CLEAR_16: bagl_glyph_e = 4;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_BACKSPACE_20: bagl_glyph_e = 5;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_CHECK: bagl_glyph_e = 6;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_CROSS: bagl_glyph_e = 7;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_CHECK_BADGE: bagl_glyph_e = 8;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_LEFT: bagl_glyph_e = 9;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_RIGHT: bagl_glyph_e = 10;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_UP: bagl_glyph_e = 11;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_DOWN: bagl_glyph_e = 12;
pub const bagl_glyph_e_BAGL_GLYPH_LOGO_LEDGER_MINI: bagl_glyph_e = 13;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_CROSS_BADGE: bagl_glyph_e = 14;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_DASHBOARD_BADGE: bagl_glyph_e = 15;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_PLUS: bagl_glyph_e = 16;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_LESS: bagl_glyph_e = 17;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_TOGGLE_ON: bagl_glyph_e = 18;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_TOGGLE_OFF: bagl_glyph_e = 19;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_LOADING_BADGE: bagl_glyph_e = 20;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_COG_BADGE: bagl_glyph_e = 21;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_WARNING_BADGE: bagl_glyph_e = 22;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_DOWNLOAD_BADGE: bagl_glyph_e = 23;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_TRANSACTION_BADGE: bagl_glyph_e = 24;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_BITCOIN_BADGE: bagl_glyph_e = 25;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_ETHEREUM_BADGE: bagl_glyph_e = 26;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_EYE_BADGE: bagl_glyph_e = 27;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_PEOPLE_BADGE: bagl_glyph_e = 28;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_LOCK_BADGE: bagl_glyph_e = 29;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_BLUE_CABLE: bagl_glyph_e = 30;
pub const bagl_glyph_e_BAGL_GLYPH_TEXT_WELCOME: bagl_glyph_e = 31;
pub const bagl_glyph_e_BAGL_GLYPH_LOGO_LEDGER_BOOT: bagl_glyph_e = 32;
pub const bagl_glyph_e_BAGL_GLYPH_BATT_LEFT: bagl_glyph_e = 33;
pub const bagl_glyph_e_BAGL_GLYPH_BATT_RIGHT: bagl_glyph_e = 34;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_LIGHTNING: bagl_glyph_e = 35;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_PLUG: bagl_glyph_e = 36;
pub const bagl_glyph_e_BAGL_GLYPH_BADGE_DOWNLOAD_BLUE: bagl_glyph_e = 37;
pub const bagl_glyph_e_BAGL_GLYPH_BADGE_WARNING_BLUE: bagl_glyph_e = 38;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_LOADER_BLUE: bagl_glyph_e = 39;
pub const bagl_glyph_e_BAGL_GLYPH_BADGE_CHECKMARK_BLUE: bagl_glyph_e = 40;
pub const bagl_glyph_e_BAGL_GLYPH_BADGE_WRENCH_BLUE: bagl_glyph_e = 41;
pub const bagl_glyph_e_BAGL_GLYPH_BADGE_ERROR_BLUE: bagl_glyph_e = 42;
pub const bagl_glyph_e_BAGL_GLYPH_BADGE_POWER_BLUE: bagl_glyph_e = 43;
pub const bagl_glyph_e_BAGL_GLYPH_BADGE_CRITICAL_BLUE: bagl_glyph_e = 44;
pub const bagl_glyph_e_BAGL_GLYPH_BADGE_ASSISTANCE_BLUE: bagl_glyph_e = 45;
pub const bagl_glyph_e_BAGL_GLYPH_BADGE_LOCK_BLUE: bagl_glyph_e = 46;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_CHECKMARK_BLUE: bagl_glyph_e = 47;
pub const bagl_glyph_e_BAGL_GLYPH_APP_FIRMWARE_BLUE: bagl_glyph_e = 48;
pub const bagl_glyph_e_BAGL_GLYPH_BADGE_BLUE: bagl_glyph_e = 49;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_BRIGHTNESS_LOW_BLUE: bagl_glyph_e = 50;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_BRIGHTNESS_HIGH_BLUE: bagl_glyph_e = 51;
pub type bagl_glyph_e = cty::c_uint;
extern "C" {
    pub fn bagl_compute_line_width(
        font_id: cty::c_ushort,
        width: cty::c_ushort,
        text: *const cty::c_void,
        text_length: cty::c_uchar,
        text_encoding: cty::c_uchar,
    ) -> cty::c_ushort;
}
extern "C" {
    pub fn bagl_draw_string(
        font_id: cty::c_ushort,
        color1: cty::c_uint,
        color0: cty::c_uint,
        x: cty::c_int,
        y: cty::c_int,
        width: cty::c_uint,
        height: cty::c_uint,
        text: *const cty::c_void,
        text_length: cty::c_uint,
        text_encoding: cty::c_uchar,
    ) -> cty::c_int;
}
extern "C" {
    pub fn bagl_draw_bg(color: cty::c_uint);
}
extern "C" {
    pub fn bagl_draw_with_context(
        component: *const bagl_component_t,
        text: *const cty::c_void,
        text_length: cty::c_ushort,
        text_encoding: cty::c_uchar,
    );
}
extern "C" {
    pub fn bagl_draw(component: *const bagl_component_t);
}
extern "C" {
    pub fn bagl_draw_glyph(
        component: *const bagl_component_t,
        icon_details: *const bagl_icon_details_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bagl_animated_s {
    pub c: bagl_component_t,
    pub text: *mut cty::c_void,
    pub text_length: cty::c_ushort,
    pub text_encoding: cty::c_uchar,
    pub current_char_idx: cty::c_uint,
    pub current_x: cty::c_uint,
    pub next_ms: cty::c_uint,
}
#[test]
fn bindgen_test_layout_bagl_animated_s() {
    assert_eq!(
        ::core::mem::size_of::<bagl_animated_s>(),
        52usize,
        concat!("Size of: ", stringify!(bagl_animated_s))
    );
    assert_eq!(
        ::core::mem::align_of::<bagl_animated_s>(),
        4usize,
        concat!("Alignment of ", stringify!(bagl_animated_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_animated_s>())).c as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_animated_s),
            "::",
            stringify!(c)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_animated_s>())).text as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_animated_s),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_animated_s>())).text_length as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_animated_s),
            "::",
            stringify!(text_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_animated_s>())).text_encoding as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_animated_s),
            "::",
            stringify!(text_encoding)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bagl_animated_s>())).current_char_idx as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_animated_s),
            "::",
            stringify!(current_char_idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_animated_s>())).current_x as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_animated_s),
            "::",
            stringify!(current_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_animated_s>())).next_ms as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_animated_s),
            "::",
            stringify!(next_ms)
        )
    );
}
impl Default for bagl_animated_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type bagl_animated_t = bagl_animated_s;
extern "C" {
    pub fn bagl_animate(
        anim: *mut bagl_animated_t,
        timestamp_ms: cty::c_uint,
        interval_ms: cty::c_uint,
    );
}
extern "C" {
    pub fn bagl_hal_draw_bitmap_within_rect(
        x: cty::c_int,
        y: cty::c_int,
        width: cty::c_uint,
        height: cty::c_uint,
        color_count: cty::c_uint,
        colors: *const cty::c_uint,
        bit_per_pixel: cty::c_uint,
        bitmap: *const cty::c_uchar,
        bitmap_length_bits: cty::c_uint,
    );
}
extern "C" {
    pub fn bagl_hal_draw_bitmap_continue(
        bit_per_pixel: cty::c_uint,
        bitmap: *const cty::c_uchar,
        bitmap_length_bits: cty::c_uint,
    );
}
extern "C" {
    pub fn bagl_hal_draw_rect(
        color: cty::c_uint,
        x: cty::c_int,
        y: cty::c_int,
        width: cty::c_uint,
        height: cty::c_uint,
    );
}
extern "C" {
    pub fn bagl_action(component: *const bagl_component_t, event_kind: cty::c_uchar);
}
extern "C" {
    pub static mut G_io_apdu_buffer: [cty::c_uchar; 260usize];
}
extern "C" {
    pub fn io_exchange(channel_and_flags: cty::c_uchar, tx_len: cty::c_ushort) -> cty::c_ushort;
}
pub const io_apdu_media_t_IO_APDU_MEDIA_NONE: io_apdu_media_t = 0;
pub const io_apdu_media_t_IO_APDU_MEDIA_USB_HID: io_apdu_media_t = 1;
pub const io_apdu_media_t_IO_APDU_MEDIA_BLE: io_apdu_media_t = 2;
pub const io_apdu_media_t_IO_APDU_MEDIA_NFC: io_apdu_media_t = 3;
pub const io_apdu_media_t_IO_APDU_MEDIA_USB_CCID: io_apdu_media_t = 4;
pub const io_apdu_media_t_IO_APDU_MEDIA_USB_WEBUSB: io_apdu_media_t = 5;
pub const io_apdu_media_t_IO_APDU_MEDIA_RAW: io_apdu_media_t = 6;
pub const io_apdu_media_t_IO_APDU_MEDIA_U2F: io_apdu_media_t = 7;
pub type io_apdu_media_t = cty::c_uint;
extern "C" {
    pub static mut G_io_usb_ep_buffer: [cty::c_uchar; 64usize];
}
extern "C" {
    #[doc = " Return 1 when the event has been processed, 0 else"]
    pub fn io_event(channel: cty::c_uchar) -> cty::c_uchar;
}
pub type __int8_t = cty::c_schar;
pub type __uint8_t = cty::c_uchar;
pub type __int16_t = cty::c_short;
pub type __uint16_t = cty::c_ushort;
pub type __int32_t = cty::c_int;
pub type __uint32_t = cty::c_uint;
pub type __int64_t = cty::c_longlong;
pub type __uint64_t = cty::c_ulonglong;
pub type __int_least8_t = cty::c_schar;
pub type __uint_least8_t = cty::c_uchar;
pub type __int_least16_t = cty::c_short;
pub type __uint_least16_t = cty::c_ushort;
pub type __int_least32_t = cty::c_int;
pub type __uint_least32_t = cty::c_uint;
pub type __int_least64_t = cty::c_longlong;
pub type __uint_least64_t = cty::c_ulonglong;
pub type __intmax_t = cty::c_longlong;
pub type __uintmax_t = cty::c_ulonglong;
pub type __intptr_t = cty::c_int;
pub type __uintptr_t = cty::c_uint;
pub type size_t = cty::c_uint;
pub type wchar_t = cty::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: cty::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::core::mem::size_of::<max_align_t>(),
        16usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<max_align_t>(),
        8usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type va_list = u32;
pub type __gnuc_va_list = u32;
pub type wint_t = cty::c_int;
pub type __blkcnt_t = cty::c_long;
pub type __blksize_t = cty::c_long;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint32_t;
pub type _off_t = cty::c_long;
pub type __pid_t = cty::c_int;
pub type __dev_t = cty::c_short;
pub type __uid_t = cty::c_ushort;
pub type __gid_t = cty::c_ushort;
pub type __id_t = __uint32_t;
pub type __ino_t = cty::c_ushort;
pub type __mode_t = __uint32_t;
pub type _off64_t = cty::c_longlong;
pub type __off_t = _off_t;
pub type __loff_t = _off64_t;
pub type __key_t = cty::c_long;
pub type _fpos_t = cty::c_long;
pub type __size_t = cty::c_uint;
pub type _ssize_t = cty::c_int;
pub type __ssize_t = _ssize_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: cty::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [cty::c_uchar; 4usize],
}
#[test]
fn bindgen_test_layout__mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
impl Default for _mbstate_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__mbstate_t() {
    assert_eq!(
        ::core::mem::size_of::<_mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(_mbstate_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
impl Default for _mbstate_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type _iconv_t = *mut cty::c_void;
pub type __clock_t = cty::c_ulong;
pub type __time_t = __int_least64_t;
pub type __clockid_t = cty::c_ulong;
pub type __timer_t = cty::c_ulong;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __nl_item = cty::c_int;
pub type __nlink_t = cty::c_ushort;
pub type __suseconds_t = cty::c_long;
pub type __useconds_t = cty::c_ulong;
pub type __va_list = u32;
pub type __ULong = cty::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lock {
    _unused: [u8; 0],
}
pub type _LOCK_T = *mut __lock;
extern "C" {
    pub fn __retarget_lock_init(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_init_recursive(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_close(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_close_recursive(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_acquire(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_acquire_recursive(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_try_acquire(lock: _LOCK_T) -> cty::c_int;
}
extern "C" {
    pub fn __retarget_lock_try_acquire_recursive(lock: _LOCK_T) -> cty::c_int;
}
extern "C" {
    pub fn __retarget_lock_release(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_release_recursive(lock: _LOCK_T);
}
pub type _flock_t = _LOCK_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: cty::c_int,
    pub _maxwds: cty::c_int,
    pub _sign: cty::c_int,
    pub _wds: cty::c_int,
    pub _x: [__ULong; 1usize],
}
#[test]
fn bindgen_test_layout__Bigint() {
    assert_eq!(
        ::core::mem::size_of::<_Bigint>(),
        24usize,
        concat!("Size of: ", stringify!(_Bigint))
    );
    assert_eq!(
        ::core::mem::align_of::<_Bigint>(),
        4usize,
        concat!("Alignment of ", stringify!(_Bigint))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_Bigint>()))._next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_Bigint>()))._k as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_k)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_Bigint>()))._maxwds as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_maxwds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_Bigint>()))._sign as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_sign)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_Bigint>()))._wds as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_wds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_Bigint>()))._x as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_x)
        )
    );
}
impl Default for _Bigint {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __tm {
    pub __tm_sec: cty::c_int,
    pub __tm_min: cty::c_int,
    pub __tm_hour: cty::c_int,
    pub __tm_mday: cty::c_int,
    pub __tm_mon: cty::c_int,
    pub __tm_year: cty::c_int,
    pub __tm_wday: cty::c_int,
    pub __tm_yday: cty::c_int,
    pub __tm_isdst: cty::c_int,
}
#[test]
fn bindgen_test_layout___tm() {
    assert_eq!(
        ::core::mem::size_of::<__tm>(),
        36usize,
        concat!("Size of: ", stringify!(__tm))
    );
    assert_eq!(
        ::core::mem::align_of::<__tm>(),
        4usize,
        concat!("Alignment of ", stringify!(__tm))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tm>())).__tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tm>())).__tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tm>())).__tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tm>())).__tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tm>())).__tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tm>())).__tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tm>())).__tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tm>())).__tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tm>())).__tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_isdst)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _on_exit_args {
    pub _fnargs: [*mut cty::c_void; 32usize],
    pub _dso_handle: [*mut cty::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
#[test]
fn bindgen_test_layout__on_exit_args() {
    assert_eq!(
        ::core::mem::size_of::<_on_exit_args>(),
        264usize,
        concat!("Size of: ", stringify!(_on_exit_args))
    );
    assert_eq!(
        ::core::mem::align_of::<_on_exit_args>(),
        4usize,
        concat!("Alignment of ", stringify!(_on_exit_args))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_on_exit_args>()))._fnargs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_fnargs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_on_exit_args>()))._dso_handle as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_dso_handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_on_exit_args>()))._fntypes as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_fntypes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_on_exit_args>()))._is_cxa as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_is_cxa)
        )
    );
}
impl Default for _on_exit_args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: cty::c_int,
    pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args: _on_exit_args,
}
#[test]
fn bindgen_test_layout__atexit() {
    assert_eq!(
        ::core::mem::size_of::<_atexit>(),
        400usize,
        concat!("Size of: ", stringify!(_atexit))
    );
    assert_eq!(
        ::core::mem::align_of::<_atexit>(),
        4usize,
        concat!("Alignment of ", stringify!(_atexit))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_atexit>()))._next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_atexit>()))._ind as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_ind)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_atexit>()))._fns as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_fns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_atexit>()))._on_exit_args as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_on_exit_args)
        )
    );
}
impl Default for _atexit {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut cty::c_uchar,
    pub _size: cty::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    assert_eq!(
        ::core::mem::size_of::<__sbuf>(),
        8usize,
        concat!("Size of: ", stringify!(__sbuf))
    );
    assert_eq!(
        ::core::mem::align_of::<__sbuf>(),
        4usize,
        concat!("Alignment of ", stringify!(__sbuf))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sbuf>()))._base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sbuf>()))._size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_size)
        )
    );
}
impl Default for __sbuf {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut cty::c_uchar,
    pub _r: cty::c_int,
    pub _w: cty::c_int,
    pub _flags: cty::c_short,
    pub _file: cty::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: cty::c_int,
    pub _cookie: *mut cty::c_void,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut cty::c_void,
            arg3: *mut cty::c_char,
            arg4: cty::c_int,
        ) -> cty::c_int,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut cty::c_void,
            arg3: *const cty::c_char,
            arg4: cty::c_int,
        ) -> cty::c_int,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut cty::c_void,
            arg3: _fpos_t,
            arg4: cty::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut _reent, arg2: *mut cty::c_void) -> cty::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut cty::c_uchar,
    pub _ur: cty::c_int,
    pub _ubuf: [cty::c_uchar; 3usize],
    pub _nbuf: [cty::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: cty::c_int,
    pub _offset: _off_t,
    pub _data: *mut _reent,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: cty::c_int,
}
#[test]
fn bindgen_test_layout___sFILE() {
    assert_eq!(
        ::core::mem::size_of::<__sFILE>(),
        104usize,
        concat!("Size of: ", stringify!(__sFILE))
    );
    assert_eq!(
        ::core::mem::align_of::<__sFILE>(),
        4usize,
        concat!("Alignment of ", stringify!(__sFILE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_p)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._r as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_r)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._w as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_w)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._file as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._bf as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_bf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._lbfsize as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lbfsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._cookie as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_cookie)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._read as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._write as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._seek as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._close as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_close)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._ub as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ub)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._up as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_up)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._ur as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ur)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._ubuf as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ubuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._nbuf as *const _ as usize },
        67usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_nbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._lb as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._blksize as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._offset as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._data as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._lock as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._mbstate as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_mbstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._flags2 as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags2)
        )
    );
}
impl Default for __sFILE {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __FILE = __sFILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: cty::c_int,
    pub _iobs: *mut __FILE,
}
#[test]
fn bindgen_test_layout__glue() {
    assert_eq!(
        ::core::mem::size_of::<_glue>(),
        12usize,
        concat!("Size of: ", stringify!(_glue))
    );
    assert_eq!(
        ::core::mem::align_of::<_glue>(),
        4usize,
        concat!("Alignment of ", stringify!(_glue))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_glue>()))._next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_glue),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_glue>()))._niobs as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_glue),
            "::",
            stringify!(_niobs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_glue>()))._iobs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_glue),
            "::",
            stringify!(_iobs)
        )
    );
}
impl Default for _glue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _rand48 {
    pub _seed: [cty::c_ushort; 3usize],
    pub _mult: [cty::c_ushort; 3usize],
    pub _add: cty::c_ushort,
}
#[test]
fn bindgen_test_layout__rand48() {
    assert_eq!(
        ::core::mem::size_of::<_rand48>(),
        14usize,
        concat!("Size of: ", stringify!(_rand48))
    );
    assert_eq!(
        ::core::mem::align_of::<_rand48>(),
        2usize,
        concat!("Alignment of ", stringify!(_rand48))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_rand48>()))._seed as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_seed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_rand48>()))._mult as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_mult)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_rand48>()))._add as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_add)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent {
    pub _errno: cty::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: cty::c_int,
    pub _emergency: [cty::c_char; 25usize],
    pub _unspecified_locale_info: cty::c_int,
    pub _locale: *mut __locale_t,
    pub __sdidinit: cty::c_int,
    pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _result: *mut _Bigint,
    pub _result_k: cty::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
    pub _cvtlen: cty::c_int,
    pub _cvtbuf: *mut cty::c_char,
    pub _new: _reent__bindgen_ty_1,
    pub _atexit: *mut _atexit,
    pub _atexit0: _atexit,
    pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1: cty::c_int)>,
    pub __sglue: _glue,
    pub __sf: [__FILE; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _reent__bindgen_ty_1 {
    pub _reent: _reent__bindgen_ty_1__bindgen_ty_1,
    pub _unused: _reent__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_1 {
    pub _unused_rand: cty::c_uint,
    pub _strtok_last: *mut cty::c_char,
    pub _asctime_buf: [cty::c_char; 26usize],
    pub _localtime_buf: __tm,
    pub _gamma_signgam: cty::c_int,
    pub _rand_next: cty::c_ulonglong,
    pub _r48: _rand48,
    pub _mblen_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _l64a_buf: [cty::c_char; 8usize],
    pub _signal_buf: [cty::c_char; 24usize],
    pub _getdate_err: cty::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
    pub _h_errno: cty::c_int,
}
#[test]
fn bindgen_test_layout__reent__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_reent__bindgen_ty_1__bindgen_ty_1>(),
        208usize,
        concat!("Size of: ", stringify!(_reent__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._unused_rand as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_unused_rand)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._strtok_last as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_strtok_last)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._asctime_buf as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_asctime_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._localtime_buf
                as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_localtime_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._gamma_signgam
                as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_gamma_signgam)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._rand_next as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_rand_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._r48 as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_r48)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._mblen_state as *const _
                as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mblen_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._mbtowc_state
                as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbtowc_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._wctomb_state
                as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_wctomb_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._l64a_buf as *const _
                as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_l64a_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._signal_buf as *const _
                as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_signal_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._getdate_err as *const _
                as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_getdate_err)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._mbrlen_state
                as *const _ as usize
        },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbrlen_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._mbrtowc_state
                as *const _ as usize
        },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbrtowc_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._mbsrtowcs_state
                as *const _ as usize
        },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbsrtowcs_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._wcrtomb_state
                as *const _ as usize
        },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_wcrtomb_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._wcsrtombs_state
                as *const _ as usize
        },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_wcsrtombs_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._h_errno as *const _
                as usize
        },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_h_errno)
        )
    );
}
impl Default for _reent__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_2 {
    pub _nextf: [*mut cty::c_uchar; 30usize],
    pub _nmalloc: [cty::c_uint; 30usize],
}
#[test]
fn bindgen_test_layout__reent__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<_reent__bindgen_ty_1__bindgen_ty_2>(),
        240usize,
        concat!("Size of: ", stringify!(_reent__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_2>()))._nextf as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_nextf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_2>()))._nmalloc as *const _
                as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_nmalloc)
        )
    );
}
impl Default for _reent__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__reent__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_reent__bindgen_ty_1>(),
        240usize,
        concat!("Size of: ", stringify!(_reent__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_reent__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent__bindgen_ty_1>()))._reent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1),
            "::",
            stringify!(_reent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent__bindgen_ty_1>()))._unused as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1),
            "::",
            stringify!(_unused)
        )
    );
}
impl Default for _reent__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__reent() {
    assert_eq!(
        ::core::mem::size_of::<_reent>(),
        1064usize,
        concat!("Size of: ", stringify!(_reent))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent>(),
        8usize,
        concat!("Alignment of ", stringify!(_reent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._errno as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_errno)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._stdin as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_stdin)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._stdout as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_stdout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._stderr as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_stderr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._inc as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_inc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._emergency as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_emergency)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent>()))._unspecified_locale_info as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_unspecified_locale_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._locale as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_locale)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>())).__sdidinit as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__sdidinit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>())).__cleanup as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__cleanup)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._result as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_result)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._result_k as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_result_k)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._p5s as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_p5s)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._freelist as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_freelist)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._cvtlen as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_cvtlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._cvtbuf as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_cvtbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._new as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_new)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._atexit as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_atexit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._atexit0 as *const _ as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_atexit0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._sig_func as *const _ as usize },
        732usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_sig_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>())).__sglue as *const _ as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__sglue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>())).__sf as *const _ as usize },
        748usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__sf)
        )
    );
}
impl Default for _reent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut _impure_ptr: *mut _reent;
}
extern "C" {
    pub static _global_impure_ptr: *mut _reent;
}
extern "C" {
    pub fn _reclaim_reent(arg1: *mut _reent);
}
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = __intptr_t;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type __sigset_t = cty::c_ulong;
pub type suseconds_t = __suseconds_t;
pub type time_t = __int_least64_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::core::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::core::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: cty::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::core::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::core::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::core::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::core::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<itimerspec>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
pub type sigset_t = __sigset_t;
pub type fd_mask = cty::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _types_fd_set {
    pub fds_bits: [fd_mask; 2usize],
}
#[test]
fn bindgen_test_layout__types_fd_set() {
    assert_eq!(
        ::core::mem::size_of::<_types_fd_set>(),
        8usize,
        concat!("Size of: ", stringify!(_types_fd_set))
    );
    assert_eq!(
        ::core::mem::align_of::<_types_fd_set>(),
        4usize,
        concat!("Alignment of ", stringify!(_types_fd_set))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_types_fd_set>())).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_types_fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
extern "C" {
    pub fn select(
        __n: cty::c_int,
        __readfds: *mut _types_fd_set,
        __writefds: *mut _types_fd_set,
        __exceptfds: *mut _types_fd_set,
        __timeout: *mut timeval,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pselect(
        __n: cty::c_int,
        __readfds: *mut _types_fd_set,
        __writefds: *mut _types_fd_set,
        __exceptfds: *mut _types_fd_set,
        __timeout: *const timespec,
        __set: *const sigset_t,
    ) -> cty::c_int;
}
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type u_register_t = __uintptr_t;
pub type u_char = cty::c_uchar;
pub type u_short = cty::c_ushort;
pub type u_int = cty::c_uint;
pub type u_long = cty::c_ulong;
pub type ushort = cty::c_ushort;
pub type uint = cty::c_uint;
pub type ulong = cty::c_ulong;
pub type blkcnt_t = __blkcnt_t;
pub type blksize_t = __blksize_t;
pub type clock_t = cty::c_ulong;
pub type daddr_t = cty::c_long;
pub type caddr_t = *mut cty::c_char;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type off_t = __off_t;
pub type dev_t = __dev_t;
pub type uid_t = __uid_t;
pub type gid_t = __gid_t;
pub type pid_t = __pid_t;
pub type key_t = __key_t;
pub type ssize_t = _ssize_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type sbintime_t = __int64_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: cty::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    assert_eq!(
        ::core::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::core::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_param>())).sched_priority as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
}
pub type pthread_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr_t {
    pub is_initialized: cty::c_int,
    pub stackaddr: *mut cty::c_void,
    pub stacksize: cty::c_int,
    pub contentionscope: cty::c_int,
    pub inheritsched: cty::c_int,
    pub schedpolicy: cty::c_int,
    pub schedparam: sched_param,
    pub detachstate: cty::c_int,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_attr_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_attr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).is_initialized as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(is_initialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).stackaddr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(stackaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).stacksize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(stacksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).contentionscope as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(contentionscope)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).inheritsched as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(inheritsched)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).schedpolicy as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(schedpolicy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).schedparam as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(schedparam)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).detachstate as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(detachstate)
        )
    );
}
impl Default for pthread_attr_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pthread_mutex_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pthread_mutexattr_t {
    pub is_initialized: cty::c_int,
    pub recursive: cty::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_mutexattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pthread_mutexattr_t>())).is_initialized as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(is_initialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_mutexattr_t>())).recursive as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(recursive)
        )
    );
}
pub type pthread_cond_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pthread_condattr_t {
    pub is_initialized: cty::c_int,
    pub clock: clock_t,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_condattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pthread_condattr_t>())).is_initialized as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(is_initialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_condattr_t>())).clock as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(clock)
        )
    );
}
pub type pthread_key_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pthread_once_t {
    pub is_initialized: cty::c_int,
    pub init_executed: cty::c_int,
}
#[test]
fn bindgen_test_layout_pthread_once_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_once_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_once_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_once_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_once_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_once_t>())).is_initialized as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_once_t),
            "::",
            stringify!(is_initialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_once_t>())).init_executed as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_once_t),
            "::",
            stringify!(init_executed)
        )
    );
}
pub type FILE = __FILE;
pub type fpos_t = _fpos_t;
extern "C" {
    pub fn ctermid(arg1: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn tempnam(arg1: *const cty::c_char, arg2: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn freopen(
        arg1: *const cty::c_char,
        arg2: *const cty::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut cty::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut cty::c_char,
        arg3: cty::c_int,
        arg4: size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn fprintf(arg1: *mut FILE, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn fscanf(arg1: *mut FILE, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn printf(arg1: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn scanf(arg1: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn sscanf(arg1: *const cty::c_char, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn vfprintf(arg1: *mut FILE, arg2: *const cty::c_char, arg3: u32) -> cty::c_int;
}
extern "C" {
    pub fn vprintf(arg1: *const cty::c_char, arg2: u32) -> cty::c_int;
}
extern "C" {
    pub fn vsprintf(arg1: *mut cty::c_char, arg2: *const cty::c_char, arg3: u32) -> cty::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fgets(arg1: *mut cty::c_char, arg2: cty::c_int, arg3: *mut FILE) -> *mut cty::c_char;
}
extern "C" {
    pub fn fputc(arg1: cty::c_int, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const cty::c_char, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn getchar() -> cty::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn putc(arg1: cty::c_int, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn putchar(arg1: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn puts(arg1: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn ungetc(arg1: cty::c_int, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fread(
        arg1: *mut cty::c_void,
        _size: cty::c_uint,
        _n: cty::c_uint,
        arg2: *mut FILE,
    ) -> cty::c_uint;
}
extern "C" {
    pub fn fwrite(
        arg1: *const cty::c_void,
        _size: cty::c_uint,
        _n: cty::c_uint,
        arg2: *mut FILE,
    ) -> cty::c_uint;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> cty::c_int;
}
extern "C" {
    pub fn fseek(arg1: *mut FILE, arg2: cty::c_long, arg3: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> cty::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> cty::c_long;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn perror(arg1: *const cty::c_char);
}
extern "C" {
    pub fn fopen(_name: *const cty::c_char, _type: *const cty::c_char) -> *mut FILE;
}
extern "C" {
    pub fn sprintf(arg1: *mut cty::c_char, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn remove(arg1: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn rename(arg1: *const cty::c_char, arg2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn fseeko(arg1: *mut FILE, arg2: off_t, arg3: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn ftello(arg1: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(
        arg1: *mut cty::c_char,
        arg2: cty::c_uint,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn vsnprintf(
        arg1: *mut cty::c_char,
        arg2: cty::c_uint,
        arg3: *const cty::c_char,
        arg4: u32,
    ) -> cty::c_int;
}
extern "C" {
    pub fn vfscanf(arg1: *mut FILE, arg2: *const cty::c_char, arg3: u32) -> cty::c_int;
}
extern "C" {
    pub fn vscanf(arg1: *const cty::c_char, arg2: u32) -> cty::c_int;
}
extern "C" {
    pub fn vsscanf(arg1: *const cty::c_char, arg2: *const cty::c_char, arg3: u32) -> cty::c_int;
}
extern "C" {
    pub fn asiprintf(arg1: *mut *mut cty::c_char, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn asniprintf(
        arg1: *mut cty::c_char,
        arg2: *mut size_t,
        arg3: *const cty::c_char,
        ...
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn asnprintf(
        arg1: *mut cty::c_char,
        arg2: *mut size_t,
        arg3: *const cty::c_char,
        ...
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn diprintf(arg1: cty::c_int, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn fiprintf(arg1: *mut FILE, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn fiscanf(arg1: *mut FILE, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn iprintf(arg1: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn iscanf(arg1: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn siprintf(arg1: *mut cty::c_char, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn siscanf(arg1: *const cty::c_char, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn sniprintf(
        arg1: *mut cty::c_char,
        arg2: size_t,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn vasiprintf(
        arg1: *mut *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn vasniprintf(
        arg1: *mut cty::c_char,
        arg2: *mut size_t,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn vasnprintf(
        arg1: *mut cty::c_char,
        arg2: *mut size_t,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn vdiprintf(
        arg1: cty::c_int,
        arg2: *const cty::c_char,
        arg3: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn vfiprintf(arg1: *mut FILE, arg2: *const cty::c_char, arg3: __gnuc_va_list)
        -> cty::c_int;
}
extern "C" {
    pub fn vfiscanf(arg1: *mut FILE, arg2: *const cty::c_char, arg3: __gnuc_va_list) -> cty::c_int;
}
extern "C" {
    pub fn viprintf(arg1: *const cty::c_char, arg2: __gnuc_va_list) -> cty::c_int;
}
extern "C" {
    pub fn viscanf(arg1: *const cty::c_char, arg2: __gnuc_va_list) -> cty::c_int;
}
extern "C" {
    pub fn vsiprintf(
        arg1: *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn vsiscanf(
        arg1: *const cty::c_char,
        arg2: *const cty::c_char,
        arg3: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn vsniprintf(
        arg1: *mut cty::c_char,
        arg2: size_t,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn fdopen(arg1: cty::c_int, arg2: *const cty::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn popen(arg1: *const cty::c_char, arg2: *const cty::c_char) -> *mut FILE;
}
extern "C" {
    pub fn setbuffer(arg1: *mut FILE, arg2: *mut cty::c_char, arg3: cty::c_int);
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn putw(arg1: cty::c_int, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> cty::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn putc_unlocked(arg1: cty::c_int, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn dprintf(arg1: cty::c_int, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn fmemopen(arg1: *mut cty::c_void, arg2: size_t, arg3: *const cty::c_char) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(arg1: *mut *mut cty::c_char, arg2: *mut size_t) -> *mut FILE;
}
extern "C" {
    pub fn vdprintf(arg1: cty::c_int, arg2: *const cty::c_char, arg3: __gnuc_va_list)
        -> cty::c_int;
}
extern "C" {
    pub fn renameat(
        arg1: cty::c_int,
        arg2: *const cty::c_char,
        arg3: cty::c_int,
        arg4: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _asiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut cty::c_char,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _asniprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: *mut size_t,
        arg4: *const cty::c_char,
        ...
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn _asnprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: *mut size_t,
        arg4: *const cty::c_char,
        ...
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn _asprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut cty::c_char,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _diprintf_r(
        arg1: *mut _reent,
        arg2: cty::c_int,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _dprintf_r(
        arg1: *mut _reent,
        arg2: cty::c_int,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _fclose_r(arg1: *mut _reent, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _fcloseall_r(arg1: *mut _reent) -> cty::c_int;
}
extern "C" {
    pub fn _fdopen_r(arg1: *mut _reent, arg2: cty::c_int, arg3: *const cty::c_char) -> *mut FILE;
}
extern "C" {
    pub fn _fflush_r(arg1: *mut _reent, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _fgetc_r(arg1: *mut _reent, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _fgetc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _fgets_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: cty::c_int,
        arg4: *mut FILE,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn _fgets_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: cty::c_int,
        arg4: *mut FILE,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn _fgetpos_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *mut fpos_t) -> cty::c_int;
}
extern "C" {
    pub fn _fsetpos_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *const fpos_t) -> cty::c_int;
}
extern "C" {
    pub fn _fiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _fiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _fmemopen_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_void,
        arg3: size_t,
        arg4: *const cty::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fopen_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: *const cty::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _freopen_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: *const cty::c_char,
        arg4: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _fpurge_r(arg1: *mut _reent, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _fputc_r(arg1: *mut _reent, arg2: cty::c_int, arg3: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _fputc_unlocked_r(arg1: *mut _reent, arg2: cty::c_int, arg3: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _fputs_r(arg1: *mut _reent, arg2: *const cty::c_char, arg3: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _fputs_unlocked_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: *mut FILE,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _fread_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_void,
        _size: size_t,
        _n: size_t,
        arg3: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn _fread_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_void,
        _size: size_t,
        _n: size_t,
        arg3: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn _fscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _fseek_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: cty::c_long,
        arg4: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _fseeko_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: _off_t,
        arg4: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _ftell_r(arg1: *mut _reent, arg2: *mut FILE) -> cty::c_long;
}
extern "C" {
    pub fn _ftello_r(arg1: *mut _reent, arg2: *mut FILE) -> _off_t;
}
extern "C" {
    pub fn _rewind_r(arg1: *mut _reent, arg2: *mut FILE);
}
extern "C" {
    pub fn _fwrite_r(
        arg1: *mut _reent,
        arg2: *const cty::c_void,
        _size: size_t,
        _n: size_t,
        arg3: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn _fwrite_unlocked_r(
        arg1: *mut _reent,
        arg2: *const cty::c_void,
        _size: size_t,
        _n: size_t,
        arg3: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn _getc_r(arg1: *mut _reent, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _getc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _getchar_r(arg1: *mut _reent) -> cty::c_int;
}
extern "C" {
    pub fn _getchar_unlocked_r(arg1: *mut _reent) -> cty::c_int;
}
extern "C" {
    pub fn _gets_r(arg1: *mut _reent, arg2: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn _iprintf_r(arg1: *mut _reent, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn _iscanf_r(arg1: *mut _reent, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn _open_memstream_r(
        arg1: *mut _reent,
        arg2: *mut *mut cty::c_char,
        arg3: *mut size_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _perror_r(arg1: *mut _reent, arg2: *const cty::c_char);
}
extern "C" {
    pub fn _printf_r(arg1: *mut _reent, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn _putc_r(arg1: *mut _reent, arg2: cty::c_int, arg3: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _putc_unlocked_r(arg1: *mut _reent, arg2: cty::c_int, arg3: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _putchar_unlocked_r(arg1: *mut _reent, arg2: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn _putchar_r(arg1: *mut _reent, arg2: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn _puts_r(arg1: *mut _reent, arg2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn _remove_r(arg1: *mut _reent, arg2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn _rename_r(
        arg1: *mut _reent,
        _old: *const cty::c_char,
        _new: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _scanf_r(arg1: *mut _reent, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn _siprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _siscanf_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _sniprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: size_t,
        arg4: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _snprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: size_t,
        arg4: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _sprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _sscanf_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _tempnam_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: *const cty::c_char,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn _tmpfile_r(arg1: *mut _reent) -> *mut FILE;
}
extern "C" {
    pub fn _tmpnam_r(arg1: *mut _reent, arg2: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn _ungetc_r(arg1: *mut _reent, arg2: cty::c_int, arg3: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _vasiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut cty::c_char,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vasniprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: *mut size_t,
        arg4: *const cty::c_char,
        arg5: __gnuc_va_list,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn _vasnprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: *mut size_t,
        arg4: *const cty::c_char,
        arg5: __gnuc_va_list,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn _vasprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut cty::c_char,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vdiprintf_r(
        arg1: *mut _reent,
        arg2: cty::c_int,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vdprintf_r(
        arg1: *mut _reent,
        arg2: cty::c_int,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vfiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vfiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vfprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vfscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _viprintf_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _viscanf_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vprintf_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vscanf_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vsiprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vsiscanf_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vsniprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: size_t,
        arg4: *const cty::c_char,
        arg5: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vsnprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: size_t,
        arg4: *const cty::c_char,
        arg5: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vsprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vsscanf_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn __getdelim(
        arg1: *mut *mut cty::c_char,
        arg2: *mut size_t,
        arg3: cty::c_int,
        arg4: *mut FILE,
    ) -> ssize_t;
}
extern "C" {
    pub fn __getline(arg1: *mut *mut cty::c_char, arg2: *mut size_t, arg3: *mut FILE) -> ssize_t;
}
extern "C" {
    pub fn clearerr_unlocked(arg1: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn ferror_unlocked(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fileno_unlocked(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fflush_unlocked(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fputc_unlocked(arg1: cty::c_int, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fread_unlocked(
        arg1: *mut cty::c_void,
        _size: size_t,
        _n: size_t,
        arg2: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fwrite_unlocked(
        arg1: *const cty::c_void,
        _size: size_t,
        _n: size_t,
        arg2: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn __srget_r(arg1: *mut _reent, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn __swbuf_r(arg1: *mut _reent, arg2: cty::c_int, arg3: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn funopen(
        __cookie: *const cty::c_void,
        __readfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut cty::c_void,
                __buf: *mut cty::c_char,
                __n: cty::c_int,
            ) -> cty::c_int,
        >,
        __writefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut cty::c_void,
                __buf: *const cty::c_char,
                __n: cty::c_int,
            ) -> cty::c_int,
        >,
        __seekfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut cty::c_void,
                __off: fpos_t,
                __whence: cty::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::core::option::Option<
            unsafe extern "C" fn(__cookie: *mut cty::c_void) -> cty::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _funopen_r(
        arg1: *mut _reent,
        __cookie: *const cty::c_void,
        __readfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut cty::c_void,
                __buf: *mut cty::c_char,
                __n: cty::c_int,
            ) -> cty::c_int,
        >,
        __writefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut cty::c_void,
                __buf: *const cty::c_char,
                __n: cty::c_int,
            ) -> cty::c_int,
        >,
        __seekfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut cty::c_void,
                __off: fpos_t,
                __whence: cty::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::core::option::Option<
            unsafe extern "C" fn(__cookie: *mut cty::c_void) -> cty::c_int,
        >,
    ) -> *mut FILE;
}
pub type bolos_bool_t = cty::c_char;
pub type appmain_t = ::core::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct application_s {
    pub nvram_begin: *mut cty::c_uchar,
    pub nvram_end: *mut cty::c_uchar,
    pub main: appmain_t,
    pub flags: cty::c_uint,
    pub code_length: cty::c_uint,
    pub data_length: cty::c_uint,
    pub params_length: cty::c_uint,
    pub sha256_code_data: [cty::c_uchar; 32usize],
    pub sha256_full: [cty::c_uchar; 32usize],
}
#[test]
fn bindgen_test_layout_application_s() {
    assert_eq!(
        ::core::mem::size_of::<application_s>(),
        92usize,
        concat!("Size of: ", stringify!(application_s))
    );
    assert_eq!(
        ::core::mem::align_of::<application_s>(),
        4usize,
        concat!("Alignment of ", stringify!(application_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<application_s>())).nvram_begin as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(application_s),
            "::",
            stringify!(nvram_begin)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<application_s>())).nvram_end as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(application_s),
            "::",
            stringify!(nvram_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<application_s>())).main as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(application_s),
            "::",
            stringify!(main)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<application_s>())).flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(application_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<application_s>())).code_length as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(application_s),
            "::",
            stringify!(code_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<application_s>())).data_length as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(application_s),
            "::",
            stringify!(data_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<application_s>())).params_length as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(application_s),
            "::",
            stringify!(params_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<application_s>())).sha256_code_data as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(application_s),
            "::",
            stringify!(sha256_code_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<application_s>())).sha256_full as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(application_s),
            "::",
            stringify!(sha256_full)
        )
    );
}
impl Default for application_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type application_t = application_s;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = cty::c_schar;
pub type uint_fast8_t = cty::c_uchar;
pub type int_fast16_t = cty::c_short;
pub type uint_fast16_t = cty::c_ushort;
pub type int_fast32_t = cty::c_int;
pub type uint_fast32_t = cty::c_uint;
pub type int_fast64_t = cty::c_longlong;
pub type uint_fast64_t = cty::c_ulonglong;
extern "C" {
    pub fn u4be_encode(buffer: *mut cty::c_uchar, offset: cty::c_uint, value: cty::c_uint);
}
extern "C" {
    pub fn u4le_encode(buffer: *mut cty::c_uchar, offset: cty::c_uint, value: cty::c_uint);
}
extern "C" {
    pub fn bytes_to_hex(
        out: *mut cty::c_char,
        outl: size_t,
        value: *const cty::c_void,
        len: size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn bytes_to_lowercase_hex(
        out: *mut cty::c_char,
        outl: size_t,
        value: *const cty::c_void,
        len: size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn os_memset4(dst: *mut cty::c_void, initval: cty::c_uint, nbintval: cty::c_uint);
}
extern "C" {
    pub fn os_xor(
        dst: *mut cty::c_void,
        src1: *mut cty::c_void,
        src2: *mut cty::c_void,
        length: cty::c_uint,
    );
}
extern "C" {
    pub fn os_secure_memcmp(
        src1: *const cty::c_void,
        src2: *const cty::c_void,
        length: size_t,
    ) -> cty::c_char;
}
extern "C" {
    pub fn os_memmove(
        dest: *mut cty::c_void,
        src: *const cty::c_void,
        n: size_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn os_memcpy(
        dest: *mut cty::c_void,
        src: *const cty::c_void,
        n: size_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn os_memcmp(s1: *const cty::c_void, s2: *const cty::c_void, n: size_t) -> cty::c_int;
}
extern "C" {
    pub fn os_memset(s: *mut cty::c_void, c: cty::c_int, n: size_t) -> *mut cty::c_void;
}
pub const bolos_ux_e_BOLOS_UX_INITIALIZE: bolos_ux_e = 0;
pub const bolos_ux_e_BOLOS_UX_EVENT: bolos_ux_e = 1;
pub const bolos_ux_e_BOLOS_UX_KEYBOARD: bolos_ux_e = 2;
pub const bolos_ux_e_BOLOS_UX_WAKE_UP: bolos_ux_e = 3;
pub const bolos_ux_e_BOLOS_UX_VALIDATE_PIN: bolos_ux_e = 15;
pub const bolos_ux_e_BOLOS_UX_LAST_ID: bolos_ux_e = 16;
pub type bolos_ux_e = cty::c_uint;
pub use self::bolos_ux_e as bolos_ux_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bolos_ux_params_s {
    pub ux_id: bolos_ux_t,
    pub len: cty::c_uint,
}
#[test]
fn bindgen_test_layout_bolos_ux_params_s() {
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s>(),
        8usize,
        concat!("Size of: ", stringify!(bolos_ux_params_s))
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s>(),
        4usize,
        concat!("Alignment of ", stringify!(bolos_ux_params_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bolos_ux_params_s>())).ux_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s),
            "::",
            stringify!(ux_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bolos_ux_params_s>())).len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s),
            "::",
            stringify!(len)
        )
    );
}
impl Default for bolos_ux_params_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type bolos_ux_params_t = bolos_ux_params_s;
extern "C" {
    pub fn os_ux(params: *mut bolos_ux_params_t) -> cty::c_uint;
}
extern "C" {
    pub fn os_ux_result(params: *mut bolos_ux_params_t);
}
extern "C" {
    pub fn os_ux_blocking(params: *mut bolos_ux_params_t) -> cty::c_uint;
}
extern "C" {
    pub static mut G_io_seproxyhal_spi_buffer: [cty::c_uchar; 300usize];
}
extern "C" {
    pub fn io_seph_send(buffer: *const cty::c_uchar, length: cty::c_ushort);
}
extern "C" {
    pub fn io_seph_is_status_sent() -> cty::c_uint;
}
extern "C" {
    pub fn io_seph_recv(
        buffer: *mut cty::c_uchar,
        maxlength: cty::c_ushort,
        flags: cty::c_uint,
    ) -> cty::c_ushort;
}
extern "C" {
    pub fn io_seph_init();
}
extern "C" {
    pub fn io_seproxyhal_init();
}
extern "C" {
    pub fn io_seproxyhal_init_ux();
}
extern "C" {
    pub fn io_seproxyhal_init_button();
}
extern "C" {
    pub fn io_exchange_al(channel_and_flags: cty::c_uchar, tx_len: cty::c_ushort) -> cty::c_ushort;
}
extern "C" {
    pub fn os_io_seproxyhal_get_app_name_and_version() -> cty::c_uint;
}
extern "C" {
    pub fn USB_power(enabled: cty::c_uchar);
}
extern "C" {
    pub fn io_seproxyhal_handle_usb_event();
}
extern "C" {
    pub fn io_seproxyhal_handle_usb_ep_xfer_event();
}
extern "C" {
    pub fn io_seproxyhal_get_ep_rx_size(epnum: u8) -> u16;
}
extern "C" {
    pub fn io_seproxyhal_handle_event() -> cty::c_uint;
}
extern "C" {
    pub fn io_seproxyhal_general_status();
}
extern "C" {
    pub fn os_io_seproxyhal_general_status_processing();
}
extern "C" {
    pub fn io_usb_send_apdu_data(buffer: *mut cty::c_uchar, length: cty::c_ushort);
}
extern "C" {
    pub fn io_usb_send_apdu_data_ep0x83(buffer: *mut cty::c_uchar, length: cty::c_ushort);
}
extern "C" {
    pub fn io_usb_send_ep(
        ep: cty::c_uint,
        buffer: *mut cty::c_uchar,
        length: cty::c_ushort,
        timeout: cty::c_uint,
    );
}
extern "C" {
    pub fn io_usb_ccid_reply(buffer: *mut cty::c_uchar, length: cty::c_ushort);
}
extern "C" {
    pub fn io_set_timeout(timeout: cty::c_uint);
}
pub const io_apdu_state_e_APDU_IDLE: io_apdu_state_e = 0;
pub const io_apdu_state_e_APDU_BLE: io_apdu_state_e = 1;
pub const io_apdu_state_e_APDU_BLE_WAIT_NOTIFY: io_apdu_state_e = 2;
pub const io_apdu_state_e_APDU_NFC_M24SR: io_apdu_state_e = 3;
pub const io_apdu_state_e_APDU_NFC_M24SR_SELECT: io_apdu_state_e = 4;
pub const io_apdu_state_e_APDU_NFC_M24SR_FIRST: io_apdu_state_e = 5;
pub const io_apdu_state_e_APDU_NFC_M24SR_RAPDU: io_apdu_state_e = 6;
pub const io_apdu_state_e_APDU_USB_HID: io_apdu_state_e = 7;
pub const io_apdu_state_e_APDU_USB_CCID: io_apdu_state_e = 8;
pub const io_apdu_state_e_APDU_U2F: io_apdu_state_e = 9;
pub const io_apdu_state_e_APDU_RAW: io_apdu_state_e = 10;
pub const io_apdu_state_e_APDU_USB_WEBUSB: io_apdu_state_e = 11;
pub type io_apdu_state_e = cty::c_uint;
#[doc = " Global type that enables to map memory onto the application zone instead of"]
#[doc = " over the os for os side"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_seph_s {
    pub apdu_state: io_apdu_state_e,
    pub apdu_length: cty::c_ushort,
    pub io_flags: cty::c_ushort,
    pub apdu_media: io_apdu_media_t,
    pub ms: cty::c_uint,
    pub usb_ep_xfer_len: [cty::c_uchar; 7usize],
    pub usb_ep_timeouts: [io_seph_s__bindgen_ty_1; 7usize],
    pub transfer_mode: cty::c_uchar,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct io_seph_s__bindgen_ty_1 {
    pub timeout: cty::c_ushort,
}
#[test]
fn bindgen_test_layout_io_seph_s__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<io_seph_s__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(io_seph_s__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<io_seph_s__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(io_seph_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<io_seph_s__bindgen_ty_1>())).timeout as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(io_seph_s__bindgen_ty_1),
            "::",
            stringify!(timeout)
        )
    );
}
#[test]
fn bindgen_test_layout_io_seph_s() {
    assert_eq!(
        ::core::mem::size_of::<io_seph_s>(),
        40usize,
        concat!("Size of: ", stringify!(io_seph_s))
    );
    assert_eq!(
        ::core::mem::align_of::<io_seph_s>(),
        4usize,
        concat!("Alignment of ", stringify!(io_seph_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_seph_s>())).apdu_state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(io_seph_s),
            "::",
            stringify!(apdu_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_seph_s>())).apdu_length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(io_seph_s),
            "::",
            stringify!(apdu_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_seph_s>())).io_flags as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(io_seph_s),
            "::",
            stringify!(io_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_seph_s>())).apdu_media as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(io_seph_s),
            "::",
            stringify!(apdu_media)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_seph_s>())).ms as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(io_seph_s),
            "::",
            stringify!(ms)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_seph_s>())).usb_ep_xfer_len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(io_seph_s),
            "::",
            stringify!(usb_ep_xfer_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_seph_s>())).usb_ep_timeouts as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(io_seph_s),
            "::",
            stringify!(usb_ep_timeouts)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_seph_s>())).transfer_mode as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(io_seph_s),
            "::",
            stringify!(transfer_mode)
        )
    );
}
impl Default for io_seph_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Global type that enables to map memory onto the application zone instead of"]
#[doc = " over the os for os side"]
pub type io_seph_app_t = io_seph_s;
extern "C" {
    pub static mut G_io_app: io_seph_app_t;
}
extern "C" {
    pub fn io_seproxyhal_setup_ticker(interval_ms: cty::c_uint);
}
extern "C" {
    pub fn io_seproxyhal_power_off();
}
extern "C" {
    pub fn io_seproxyhal_se_reset();
}
extern "C" {
    pub fn io_seproxyhal_disable_io();
}
extern "C" {
    pub fn io_seph_ux_redisplay();
}
extern "C" {
    #[doc = " Function to ensure a I/O channel is not timeouting waiting for operations"]
    #[doc = " after a long time without SEPH packet exchanges"]
    pub fn io_seproxyhal_io_heartbeat();
}
extern "C" {
    pub fn os_io_seph_recv_and_process(dont_process_ux_events: cty::c_uint) -> cty::c_uint;
}
pub type io_send_t =
    ::core::option::Option<unsafe extern "C" fn(buffer: *mut cty::c_uchar, length: cty::c_ushort)>;
pub type io_recv_t = ::core::option::Option<
    unsafe extern "C" fn(buffer: *mut cty::c_uchar, maxlenth: cty::c_ushort) -> cty::c_ushort,
>;
pub const io_usb_hid_receive_status_e_IO_USB_APDU_RESET: io_usb_hid_receive_status_e = 0;
pub const io_usb_hid_receive_status_e_IO_USB_APDU_MORE_DATA: io_usb_hid_receive_status_e = 1;
pub const io_usb_hid_receive_status_e_IO_USB_APDU_RECEIVED: io_usb_hid_receive_status_e = 2;
pub type io_usb_hid_receive_status_e = cty::c_uint;
pub use self::io_usb_hid_receive_status_e as io_usb_hid_receive_status_t;
extern "C" {
    pub static mut G_io_usb_hid_total_length: cty::c_uint;
}
extern "C" {
    pub fn io_usb_hid_init();
}
extern "C" {
    #[doc = " Receive next HID transport packet, returns IO_USB_APDU_RECEIVED when a"]
    #[doc = " complete APDU has been received in the G_io_apdu_buffer To be called"]
    #[doc = " typically upon USB OUT event"]
    pub fn io_usb_hid_receive(
        sndfct: io_send_t,
        buffer: *mut cty::c_uchar,
        l: cty::c_ushort,
    ) -> io_usb_hid_receive_status_t;
}
extern "C" {
    #[doc = " Mark the last chunk transmitted as sent."]
    #[doc = " To be called typically upon USB IN ACK event"]
    pub fn io_usb_hid_sent(sndfct: io_send_t);
}
extern "C" {
    #[doc = " Request transmission of an APDU from the G_io_apdu_buffer using the HID"]
    #[doc = " transport protocol"]
    pub fn io_usb_hid_send(sndfct: io_send_t, sndlength: cty::c_ushort);
}
extern "C" {
    pub fn os_endorsement_get_code_hash(buffer: *mut cty::c_uchar) -> cty::c_uint;
}
extern "C" {
    pub fn os_endorsement_get_public_key(
        index: cty::c_uchar,
        buffer: *mut cty::c_uchar,
    ) -> cty::c_uint;
}
extern "C" {
    pub fn os_endorsement_get_public_key_certificate(
        index: cty::c_uchar,
        buffer: *mut cty::c_uchar,
    ) -> cty::c_uint;
}
extern "C" {
    pub fn os_endorsement_key1_get_app_secret(buffer: *mut cty::c_uchar) -> cty::c_uint;
}
extern "C" {
    pub fn os_endorsement_key1_sign_data(
        src: *mut cty::c_uchar,
        srcLength: cty::c_uint,
        signature: *mut cty::c_uchar,
    ) -> cty::c_uint;
}
extern "C" {
    pub fn os_endorsement_key2_derive_sign_data(
        src: *mut cty::c_uchar,
        srcLength: cty::c_uint,
        signature: *mut cty::c_uchar,
    ) -> cty::c_uint;
}
extern "C" {
    pub fn halt();
}
extern "C" {
    pub fn os_parse_bertlv(
        mem: *mut cty::c_uchar,
        mem_len: cty::c_uint,
        tlv_instance_offset: *mut cty::c_uint,
        tag: cty::c_uint,
        offset: cty::c_uint,
        buffer: *mut *mut cty::c_void,
        maxlength: cty::c_uint,
    ) -> cty::c_uint;
}
pub type bolos_task_status_t = cty::c_uchar;
pub const task_unsecure_id_e_TASK_BOLOS: task_unsecure_id_e = 0;
pub const task_unsecure_id_e_TASK_SYSCALL: task_unsecure_id_e = 1;
pub const task_unsecure_id_e_TASK_USERTASKS_START: task_unsecure_id_e = 2;
pub const task_unsecure_id_e_TASK_USER: task_unsecure_id_e = 2;
pub const task_unsecure_id_e_TASK_SUBTASKS_START: task_unsecure_id_e = 3;
pub const task_unsecure_id_e_TASK_SUBTASK_0: task_unsecure_id_e = 3;
pub const task_unsecure_id_e_TASK_BOLOS_UX: task_unsecure_id_e = 4;
pub const task_unsecure_id_e_TASK_MAXCOUNT: task_unsecure_id_e = 5;
pub type task_unsecure_id_e = cty::c_uint;
extern "C" {
    pub fn os_sched_exec(app_idx: cty::c_uint);
}
extern "C" {
    pub fn os_sched_exit(exit_code: bolos_task_status_t);
}
extern "C" {
    pub fn os_sched_is_running(task_idx: cty::c_uint) -> bolos_bool_t;
}
extern "C" {
    #[doc = " Retrieve the last status issued by a task using either yield or exit."]
    pub fn os_sched_last_status(task_idx: cty::c_uint) -> bolos_task_status_t;
}
extern "C" {
    #[doc = " Current task is yielding the process to another task."]
    #[doc = " Meta call for task_switch with 'the enxt' task idx."]
    #[doc = " @param status is the current task status"]
    pub fn os_sched_yield(status: bolos_task_status_t);
}
extern "C" {
    #[doc = " Perform task switching"]
    #[doc = " @param task_idx is the task index to switch to"]
    #[doc = " @param status of the currently executed task"]
    #[doc = " @return the status of the previously running task"]
    pub fn os_sched_switch(task_idx: cty::c_uint, status: bolos_task_status_t);
}
extern "C" {
    #[doc = " Function that returns the currently running task identifier."]
    pub fn os_sched_current_task() -> cty::c_uint;
}
extern "C" {
    #[doc = " Create a new task with the given parameters and return its task identifier."]
    #[doc = " The newly created task is chrooted in the given nvram/ram1/ram2 segments"]
    #[doc = " and its task pointer is set at the end of ram1 segment."]
    #[doc = " The task is bound to the currently running application."]
    #[doc = " The task identifiers are not garanteed to be the same after a power cycle."]
    #[doc = " At least valid main, nvram segment, ram0 segment and stack segment must be"]
    #[doc = " provided with."]
    #[doc = " @param main The main function address to start the task with."]
    #[doc = " @param nvram The nvram segment address start"]
    #[doc = " @param nvram_length The nvram segment length"]
    #[doc = " @param ram0 /ram0_length the first RAM segment description"]
    #[doc = " @param stack /stack_length the task's stack RAM segment description"]
    pub fn os_sched_create(
        main: *mut cty::c_void,
        nvram: *mut cty::c_void,
        nvram_length: cty::c_uint,
        ram0: *mut cty::c_void,
        ram0_length: cty::c_uint,
        stack: *mut cty::c_void,
        stack_length: cty::c_uint,
    ) -> cty::c_uint;
}
extern "C" {
    pub fn os_sched_kill(taskidx: cty::c_uint);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bolos_ux_asynch_callback_t {
    pub asynchmodal_end_callback:
        ::core::option::Option<unsafe extern "C" fn(ux_status: cty::c_uint)>,
}
#[test]
fn bindgen_test_layout_bolos_ux_asynch_callback_t() {
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_asynch_callback_t>(),
        4usize,
        concat!("Size of: ", stringify!(bolos_ux_asynch_callback_t))
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_asynch_callback_t>(),
        4usize,
        concat!("Alignment of ", stringify!(bolos_ux_asynch_callback_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_asynch_callback_t>())).asynchmodal_end_callback
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_asynch_callback_t),
            "::",
            stringify!(asynchmodal_end_callback)
        )
    );
}
extern "C" {
    pub static mut G_io_asynch_ux_callback: bolos_ux_asynch_callback_t;
}
extern "C" {
    pub fn os_flags() -> cty::c_uint;
}
extern "C" {
    pub fn os_version(version: *mut cty::c_uchar, maxlength: cty::c_uint) -> cty::c_uint;
}
extern "C" {
    pub fn os_serial(serial: *mut cty::c_uchar, maxlength: cty::c_uint) -> cty::c_uint;
}
extern "C" {
    pub fn os_seph_features() -> cty::c_uint;
}
extern "C" {
    pub fn os_seph_version(version: *mut cty::c_uchar, maxlength: cty::c_uint) -> cty::c_uint;
}
extern "C" {
    pub fn os_bootloader_version(version: *mut cty::c_uchar, maxlength: cty::c_uint)
        -> cty::c_uint;
}
extern "C" {
    pub fn os_get_sn(buffer: *mut cty::c_uchar) -> cty::c_uint;
}
extern "C" {
    pub fn get_api_level() -> cty::c_uint;
}
extern "C" {
    #[doc = " Library call function."]
    #[doc = " call_parameters[0] = library name string pointer (const)"]
    #[doc = " call_parameters[1] = library call identifier (0 = init, ...)"]
    #[doc = " call_parameters[2+] = called function parameters"]
    pub fn os_lib_call(call_parameters: *mut cty::c_uint);
}
extern "C" {
    pub fn os_lib_end();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct meminfo_s {
    pub free_nvram_size: cty::c_uint,
    pub appMemory: cty::c_uint,
    pub systemSize: cty::c_uint,
    pub slots: cty::c_uint,
}
#[test]
fn bindgen_test_layout_meminfo_s() {
    assert_eq!(
        ::core::mem::size_of::<meminfo_s>(),
        16usize,
        concat!("Size of: ", stringify!(meminfo_s))
    );
    assert_eq!(
        ::core::mem::align_of::<meminfo_s>(),
        4usize,
        concat!("Alignment of ", stringify!(meminfo_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<meminfo_s>())).free_nvram_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(meminfo_s),
            "::",
            stringify!(free_nvram_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<meminfo_s>())).appMemory as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(meminfo_s),
            "::",
            stringify!(appMemory)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<meminfo_s>())).systemSize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(meminfo_s),
            "::",
            stringify!(systemSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<meminfo_s>())).slots as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(meminfo_s),
            "::",
            stringify!(slots)
        )
    );
}
pub type meminfo_t = meminfo_s;
extern "C" {
    pub fn os_get_memory_info(meminfo: *mut meminfo_t);
}
extern "C" {
    pub fn nvm_write(dst_adr: *mut cty::c_void, src_adr: *mut cty::c_void, src_len: cty::c_uint);
}
extern "C" {
    pub fn nvm_erase(dst_adr: *mut cty::c_void, len: cty::c_uint);
}
extern "C" {
    pub fn nvm_write_page(page_adr: cty::c_uint);
}
extern "C" {
    pub fn nvm_erase_page(page_adr: cty::c_uint);
}
extern "C" {
    pub fn os_perso_erase_all();
}
extern "C" {
    pub fn pic(linked_address: *mut cty::c_void) -> *mut cty::c_void;
}
extern "C" {
    pub fn pic_internal(link_address: *mut cty::c_void) -> *mut cty::c_void;
}
extern "C" {
    pub fn os_perso_set_pin(identity: cty::c_uint, pin: *mut cty::c_uchar, length: cty::c_uint);
}
extern "C" {
    pub fn os_perso_set_current_identity_pin(pin: *mut cty::c_uchar, length: cty::c_uint);
}
extern "C" {
    pub fn os_global_pin_is_validated() -> bolos_bool_t;
}
extern "C" {
    #[doc = " Validating the pin also setup the identity linked with this pin (normal or"]
    #[doc = " alternate)"]
    #[doc = " @return BOLOS_UX_OK if pin validated"]
    pub fn os_global_pin_check(
        pin_buffer: *mut cty::c_uchar,
        pin_length: cty::c_uchar,
    ) -> bolos_bool_t;
}
extern "C" {
    pub fn os_global_pin_invalidate();
}
extern "C" {
    pub fn os_global_pin_retries() -> cty::c_uint;
}
#[doc = " Type of error code"]
pub type cx_err_t = u32;
extern "C" {
    pub fn cx_get_random_bytes(buffer: *mut cty::c_void, len: size_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @param appidx The application entry index in the registry (raw, not filtering"]
    #[doc = " ux or whatever). If the entry index correspond to the application being"]
    #[doc = " installed then RAM structure content is used instead of the NVRAM registry."]
    #[doc = " @param tlvoffset The offset within the install parameters memory area, in"]
    #[doc = " bytes. Useful if tag is present multiple times. Can be null. The tlv offset"]
    #[doc = " is the offset of the tag in the install parameters area when a tag is"]
    #[doc = " matched. This way long tag can be read in multiple time without the need to"]
    #[doc = " play with the tlvoffset. Add +1 to skip to the next one when seraching for"]
    #[doc = " multiple tag occurences."]
    #[doc = " @param tag The tag to be searched for"]
    #[doc = " @param value_offset The offset within the value for this occurence of the"]
    #[doc = " tag. The OS_REGISTRY_GET_TAG_OFFSET_COMPARE_WITH_BUFFER or"]
    #[doc = " OS_REGISTRY_GET_TAG_OFFSET_GET_LENGTH can be ORed to perform meta operation"]
    #[doc = " on the TLV occurence."]
    #[doc = " @param buffer The user buffer for comparison or to retrieve the value of the"]
    #[doc = " tag at the given offset."]
    #[doc = " @param maxlength Size of the buffer to be compared OR to be retrieved"]
    #[doc = " (trimmed depending the TLV effective length)."]
    pub fn os_registry_get_tag(
        app_idx: cty::c_uint,
        tlvoffset: *mut cty::c_uint,
        tag: cty::c_uint,
        value_offset: cty::c_uint,
        buffer: *mut cty::c_void,
        maxlength: cty::c_uint,
    ) -> cty::c_uint;
}
extern "C" {
    pub fn os_registry_get_current_app_tag(
        tag: cty::c_uint,
        buffer: *mut cty::c_uchar,
        maxlen: cty::c_uint,
    ) -> cty::c_uint;
}
extern "C" {
    #[doc = " This function deletes the application mentioned with its index, as well as"]
    #[doc = " all its dependees (the applications which depend on it)."]
    #[doc = " @param index The index of the the application to suppress."]
    pub fn os_registry_delete_app_and_dependees(app_idx: cty::c_uint);
}
extern "C" {
    #[doc = " This function deletes all the installed applications."]
    pub fn os_registry_delete_all_apps();
}
extern "C" {
    pub fn os_registry_count() -> cty::c_uint;
}
extern "C" {
    pub fn os_registry_get(app_idx: cty::c_uint, out_application_entry: *mut application_t);
}
pub const generic_identifiers_ERR_GEN_ID_01: generic_identifiers = 1;
pub const generic_identifiers_ERR_GEN_ID_02: generic_identifiers = 2;
pub const generic_identifiers_ERR_GEN_ID_03: generic_identifiers = 3;
pub const generic_identifiers_ERR_GEN_ID_04: generic_identifiers = 4;
pub const generic_identifiers_ERR_GEN_ID_05: generic_identifiers = 5;
pub const generic_identifiers_ERR_GEN_ID_06: generic_identifiers = 6;
pub const generic_identifiers_ERR_GEN_ID_07: generic_identifiers = 7;
pub const generic_identifiers_ERR_GEN_ID_08: generic_identifiers = 8;
pub const generic_identifiers_ERR_GEN_ID_09: generic_identifiers = 9;
pub const generic_identifiers_ERR_GEN_ID_0A: generic_identifiers = 10;
pub const generic_identifiers_ERR_GEN_ID_0B: generic_identifiers = 11;
pub const generic_identifiers_ERR_GEN_ID_0C: generic_identifiers = 12;
pub const generic_identifiers_ERR_GEN_ID_0D: generic_identifiers = 13;
pub const generic_identifiers_ERR_GEN_ID_0E: generic_identifiers = 14;
pub const generic_identifiers_ERR_GEN_ID_0F: generic_identifiers = 15;
pub const generic_identifiers_ERR_GEN_ID_10: generic_identifiers = 16;
pub const generic_identifiers_ERR_GEN_ID_11: generic_identifiers = 17;
pub const generic_identifiers_ERR_GEN_ID_12: generic_identifiers = 18;
pub const generic_identifiers_ERR_GEN_ID_13: generic_identifiers = 19;
pub const generic_identifiers_ERR_GEN_ID_14: generic_identifiers = 20;
pub const generic_identifiers_ERR_GEN_ID_15: generic_identifiers = 21;
pub const generic_identifiers_ERR_GEN_ID_16: generic_identifiers = 22;
pub const generic_identifiers_ERR_GEN_ID_17: generic_identifiers = 23;
pub const generic_identifiers_ERR_GEN_ID_18: generic_identifiers = 24;
pub const generic_identifiers_ERR_GEN_ID_19: generic_identifiers = 25;
pub const generic_identifiers_ERR_GEN_ID_1A: generic_identifiers = 26;
pub const generic_identifiers_ERR_GEN_ID_1B: generic_identifiers = 27;
pub const generic_identifiers_ERR_GEN_ID_1C: generic_identifiers = 28;
pub const generic_identifiers_ERR_GEN_ID_1D: generic_identifiers = 29;
pub const generic_identifiers_ERR_GEN_ID_1E: generic_identifiers = 30;
pub const generic_identifiers_ERR_GEN_ID_1F: generic_identifiers = 31;
pub const generic_identifiers_ERR_GEN_ID_20: generic_identifiers = 32;
pub const generic_identifiers_ERR_GEN_ID_21: generic_identifiers = 33;
pub const generic_identifiers_ERR_GEN_ID_22: generic_identifiers = 34;
pub const generic_identifiers_ERR_GEN_ID_23: generic_identifiers = 35;
pub const generic_identifiers_ERR_GEN_ID_24: generic_identifiers = 36;
pub const generic_identifiers_ERR_GEN_ID_25: generic_identifiers = 37;
pub const generic_identifiers_ERR_GEN_ID_26: generic_identifiers = 38;
pub const generic_identifiers_ERR_GEN_ID_27: generic_identifiers = 39;
pub const generic_identifiers_ERR_GEN_ID_28: generic_identifiers = 40;
pub const generic_identifiers_ERR_GEN_ID_29: generic_identifiers = 41;
pub const generic_identifiers_ERR_GEN_ID_2A: generic_identifiers = 42;
pub const generic_identifiers_ERR_GEN_ID_2B: generic_identifiers = 43;
pub type generic_identifiers = cty::c_uint;
pub type exception_t = cty::c_ushort;
pub type try_context_t = try_context_s;
pub type jmp_buf = [cty::c_uint; 10usize];
extern "C" {
    pub fn longjmp(__jmpb: *mut cty::c_uint, __retval: cty::c_int);
}
extern "C" {
    pub fn setjmp(__jmpb: *mut cty::c_uint) -> cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct try_context_s {
    pub jmp_buf: jmp_buf,
    pub previous: *mut try_context_t,
    pub ex: exception_t,
}
#[test]
fn bindgen_test_layout_try_context_s() {
    assert_eq!(
        ::core::mem::size_of::<try_context_s>(),
        48usize,
        concat!("Size of: ", stringify!(try_context_s))
    );
    assert_eq!(
        ::core::mem::align_of::<try_context_s>(),
        4usize,
        concat!("Alignment of ", stringify!(try_context_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<try_context_s>())).jmp_buf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(try_context_s),
            "::",
            stringify!(jmp_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<try_context_s>())).previous as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(try_context_s),
            "::",
            stringify!(previous)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<try_context_s>())).ex as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(try_context_s),
            "::",
            stringify!(ex)
        )
    );
}
impl Default for try_context_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn try_context_get() -> *mut try_context_t;
}
extern "C" {
    pub fn try_context_set(context: *mut try_context_t) -> *mut try_context_t;
}
extern "C" {
    pub fn os_longjmp(exception: cty::c_uint);
}
pub type uint64bits_t = u64;
#[doc = "< No message digest algorithm"]
pub const cx_md_e_CX_NONE: cx_md_e = 0;
#[doc = "< RIPEMD160 digest"]
pub const cx_md_e_CX_RIPEMD160: cx_md_e = 1;
#[doc = "< SHA224 digest"]
pub const cx_md_e_CX_SHA224: cx_md_e = 2;
#[doc = "< SHA256 digest"]
pub const cx_md_e_CX_SHA256: cx_md_e = 3;
#[doc = "< SHA384 digest"]
pub const cx_md_e_CX_SHA384: cx_md_e = 4;
#[doc = "< SHA512 digest"]
pub const cx_md_e_CX_SHA512: cx_md_e = 5;
#[doc = "< Keccak (pre-SHA3) digest"]
pub const cx_md_e_CX_KECCAK: cx_md_e = 6;
#[doc = "< SHA3 Digest"]
pub const cx_md_e_CX_SHA3: cx_md_e = 7;
#[doc = "< Keep compatibility"]
pub const cx_md_e_DEPRECATED_0: cx_md_e = 8;
#[doc = "< Blake digest"]
pub const cx_md_e_CX_BLAKE2B: cx_md_e = 9;
#[doc = "< SHAKE-128 digest"]
pub const cx_md_e_CX_SHAKE128: cx_md_e = 10;
#[doc = "< SHAKE-256 digest"]
pub const cx_md_e_CX_SHAKE256: cx_md_e = 11;
#[doc = "< SHA3-256 digest"]
pub const cx_md_e_CX_SHA3_256: cx_md_e = 12;
#[doc = "< SHA3-512 digest"]
pub const cx_md_e_CX_SHA3_512: cx_md_e = 13;
#[doc = " Message digest algorithm identifiers."]
pub type cx_md_e = cty::c_uint;
#[doc = " Message digest algorithm identifiers."]
pub use self::cx_md_e as cx_md_t;
#[doc = " @brief Common message digest context, used as abstract type."]
pub type cx_hash_t = cx_hash_header_s;
#[doc = " @brief Hash description."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_hash_info_t {
    #[doc = "< Message digest algorithm identifier"]
    pub md_type: cx_md_t,
    #[doc = "< Output size"]
    pub output_size: size_t,
    #[doc = "< Block size"]
    pub block_size: size_t,
    #[doc = "< Pointer to the initialization function"]
    pub init_func: ::core::option::Option<unsafe extern "C" fn(ctx: *mut cx_hash_t) -> cx_err_t>,
    #[doc = "< Pointer to the update function"]
    pub update_func: ::core::option::Option<
        unsafe extern "C" fn(ctx: *mut cx_hash_t, data: *const u8, len: size_t) -> cx_err_t,
    >,
    #[doc = "< Pointer to the final function"]
    pub finish_func: ::core::option::Option<
        unsafe extern "C" fn(ctx: *mut cx_hash_t, digest: *mut u8) -> cx_err_t,
    >,
    #[doc = "< Pointer to the initialization function for extendable output"]
    pub init_ex_func: ::core::option::Option<
        unsafe extern "C" fn(ctx: *mut cx_hash_t, output_size: size_t) -> cx_err_t,
    >,
    #[doc = "< Pointer to the output size function"]
    pub output_size_func:
        ::core::option::Option<unsafe extern "C" fn(ctx: *const cx_hash_t) -> size_t>,
}
#[test]
fn bindgen_test_layout_cx_hash_info_t() {
    assert_eq!(
        ::core::mem::size_of::<cx_hash_info_t>(),
        32usize,
        concat!("Size of: ", stringify!(cx_hash_info_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_hash_info_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_hash_info_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_hash_info_t>())).md_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_info_t),
            "::",
            stringify!(md_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_hash_info_t>())).output_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_info_t),
            "::",
            stringify!(output_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_hash_info_t>())).block_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_info_t),
            "::",
            stringify!(block_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_hash_info_t>())).init_func as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_info_t),
            "::",
            stringify!(init_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_hash_info_t>())).update_func as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_info_t),
            "::",
            stringify!(update_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_hash_info_t>())).finish_func as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_info_t),
            "::",
            stringify!(finish_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_hash_info_t>())).init_ex_func as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_info_t),
            "::",
            stringify!(init_ex_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cx_hash_info_t>())).output_size_func as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_info_t),
            "::",
            stringify!(output_size_func)
        )
    );
}
impl Default for cx_hash_info_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Common message digest context, used as abstract type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_hash_header_s {
    #[doc = "< Hash description"]
    pub info: *const cx_hash_info_t,
    #[doc = "< Number of already processed blocks"]
    pub counter: u32,
}
#[test]
fn bindgen_test_layout_cx_hash_header_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_hash_header_s>(),
        8usize,
        concat!("Size of: ", stringify!(cx_hash_header_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_hash_header_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_hash_header_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_hash_header_s>())).info as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_header_s),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_hash_header_s>())).counter as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_header_s),
            "::",
            stringify!(counter)
        )
    );
}
impl Default for cx_hash_header_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn cx_hash_get_size(ctx: *const cx_hash_t) -> size_t;
}
extern "C" {
    #[doc = " @brief   Hash data according to the specified algorithm."]
    #[doc = ""]
    #[doc = " @param[in]  hash    Pointer to the hash context."]
    #[doc = "                     Shall be in RAM."]
    #[doc = "                     Should be called with a cast."]
    #[doc = ""]
    #[doc = " @param[in]  mode    Crypto flag. Supported flag: CX_LAST. If set:"]
    #[doc = "                       - the structure is not modified after finishing"]
    #[doc = "                       - if out is not NULL, the message digest is stored in out"]
    #[doc = "                       - the context is NOT automatically re-initialized."]
    #[doc = ""]
    #[doc = " @param[in]  in      Input data to be hashed."]
    #[doc = ""]
    #[doc = " @param[in]  len     Length of the input data."]
    #[doc = ""]
    #[doc = " @param[out] out     Buffer where to store the message digest:"]
    #[doc = "                       - NULL (ignored) if CX_LAST is NOT set"]
    #[doc = "                       - message digest if CX_LAST is set"]
    #[doc = ""]
    #[doc = " @param[out] out_len The size of the output buffer or 0 if out is NULL."]
    #[doc = "                     If buffer is too small to store the hash a exception is returned."]
    #[doc = ""]
    #[doc = " @return             Error code:"]
    #[doc = "                     - CX_OK on success"]
    #[doc = "                     - INVALID_PARAMETER"]
    #[doc = "                     - CX_INVALID_PARAMETER"]
    pub fn cx_hash_no_throw(
        hash: *mut cx_hash_t,
        mode: u32,
        in_: *const u8,
        len: size_t,
        out: *mut u8,
        out_len: size_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Initialize a hash context."]
    #[doc = ""]
    #[doc = " @param[out] hash    Pointer to the context to be initialized."]
    #[doc = "                     The context shall be in RAM."]
    #[doc = ""]
    #[doc = " @param[in]  hash_id Message digest algorithm identifier."]
    #[doc = ""]
    #[doc = " @return             Error code:"]
    #[doc = "                     - CX_OK on success"]
    #[doc = "                     - CX_INVALID_PARAMETER"]
    pub fn cx_hash_init(hash: *mut cx_hash_t, hash_id: cx_md_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Initialize a hash context."]
    #[doc = ""]
    #[doc = " @details Initialize a hash context with a chosen output length"]
    #[doc = "          (typically for eXtendable Output Functions (XOF))."]
    #[doc = ""]
    #[doc = " @param[out] hash        Pointer to the context to be initialized."]
    #[doc = "                         The context shall be in RAM."]
    #[doc = ""]
    #[doc = " @param [in] hash_id     Hash algorithm identifier. Typically:"]
    #[doc = "                           - CX_BLAKE2B"]
    #[doc = "                           - CX_SHAKE128"]
    #[doc = "                           - CX_SHAKE256"]
    #[doc = ""]
    #[doc = " @param [in] output_size Length of the output."]
    #[doc = ""]
    #[doc = " @return                 Error code:"]
    #[doc = "                         - CX_OK on success"]
    #[doc = "                         - CX_INVALID_PARAMETER"]
    pub fn cx_hash_init_ex(hash: *mut cx_hash_t, hash_id: cx_md_t, output_size: size_t)
        -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Add more data to hash."]
    #[doc = ""]
    #[doc = " @details A call to this function is equivalent to:"]
    #[doc = "          *cx_hash_no_throw(hash, 0, in, in_len, NULL, 0)*."]
    #[doc = ""]
    #[doc = " @param[out] hash   Pointer to the hash context."]
    #[doc = ""]
    #[doc = " @param[in]  in     Input data to add to the context."]
    #[doc = ""]
    #[doc = " @param[in]  in_len Length of the input data."]
    #[doc = ""]
    #[doc = " @return            Error code:"]
    #[doc = "                    - CX_OK on success"]
    #[doc = "                    - CX_INVALID_PARAMETER"]
    #[doc = "                    - INVALID_PARAMETER"]
    pub fn cx_hash_update(hash: *mut cx_hash_t, in_: *const u8, in_len: size_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Finalize the hash."]
    #[doc = ""]
    #[doc = " @details A call to this function is equivalent to:"]
    #[doc = "          *cx_hash_no_throw(hash, CX_LAST, NULL, 0, out, out_len)*."]
    #[doc = ""]
    #[doc = " @param[in]  hash   Pointer to the hash context."]
    #[doc = ""]
    #[doc = " @param[out] digest The message digest."]
    #[doc = ""]
    #[doc = " @return            Error code:"]
    #[doc = "                    - CX_OK on success"]
    pub fn cx_hash_final(hash: *mut cx_hash_t, digest: *mut u8) -> cx_err_t;
}
#[doc = " Index of a big number."]
pub type cx_bn_t = u32;
#[doc = " @brief Montgomery context."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cx_bn_mont_ctx_t {
    #[doc = "< @private Modulus"]
    pub n: cx_bn_t,
    #[doc = "< @private Second Montgomery constant"]
    pub h: cx_bn_t,
}
#[test]
fn bindgen_test_layout_cx_bn_mont_ctx_t() {
    assert_eq!(
        ::core::mem::size_of::<cx_bn_mont_ctx_t>(),
        8usize,
        concat!("Size of: ", stringify!(cx_bn_mont_ctx_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_bn_mont_ctx_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_bn_mont_ctx_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_bn_mont_ctx_t>())).n as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_bn_mont_ctx_t),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_bn_mont_ctx_t>())).h as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_bn_mont_ctx_t),
            "::",
            stringify!(h)
        )
    );
}
extern "C" {
    #[doc = " @brief   Acquire lock to BN processor."]
    #[doc = ""]
    #[doc = " @details Reset it, set the word size and configure."]
    #[doc = "          Once locked the memory can be used."]
    #[doc = ""]
    #[doc = " @param[in] word_nbytes  Word size in byte, the size of the parameters will be"]
    #[doc = " a multiple of *word_nbytes*. This size must be a multiple of"]
    #[doc = " CX_BN_WORD_ALIGNEMENT."]
    #[doc = " @param[in] flags        Flags."]
    #[doc = ""]
    #[doc = " @return                 Error code:"]
    #[doc = "                         - CX_OK on success"]
    #[doc = "                         - CX_BN_LOCKED if already locked."]
    pub fn cx_bn_lock(word_nbytes: size_t, flags: u32) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Release the BN lock."]
    #[doc = ""]
    #[doc = " @details Erase all content data."]
    #[doc = "          Once unlocked the memory cannot be used anymore."]
    #[doc = ""]
    #[doc = " @return  Error code:"]
    #[doc = "          - CX_OK on success"]
    #[doc = "          - CX_BN_NOT_LOCKED if not locked"]
    pub fn cx_bn_unlock() -> u32;
}
extern "C" {
    #[doc = " @brief   Check if BN processor is currently locked."]
    #[doc = ""]
    #[doc = " @details The memory can be used only if the BN processor is locked."]
    #[doc = ""]
    #[doc = " @return  1 if locked, 0 otherwise."]
    pub fn cx_bn_is_locked() -> bool;
}
extern "C" {
    #[doc = " @brief   Ensure BN processor is currently locked."]
    #[doc = ""]
    #[doc = " @details If the BN processor is not locked the memory"]
    #[doc = "          cannot be used."]
    #[doc = ""]
    #[doc = " @return  Error code:"]
    #[doc = "         - CX_OK on success"]
    #[doc = "         - CX_NOT_LOCKED"]
    pub fn cx_bn_locked() -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Allocate a new BN."]
    #[doc = ""]
    #[doc = " @details The specified number of bytes is the minimal required bytes,"]
    #[doc = "          the number of words allocated will be automatically a multiple"]
    #[doc = "          of the configured word size. At this moment the BN value is set"]
    #[doc = "          to 0."]
    #[doc = ""]
    #[doc = " @param[in] x        Pointer to a BN."]
    #[doc = ""]
    #[doc = " @param[in] nbytes   Number of bytes of x."]
    #[doc = ""]
    #[doc = " @return             Error code:"]
    #[doc = "                     - CX_OK on success"]
    #[doc = "                     - CX_BN_MEMORY_FULL"]
    #[doc = "                     - CX_BN_INVALID_PARAMETER_SIZE"]
    pub fn cx_bn_alloc(x: *mut cx_bn_t, nbytes: size_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Allocate a new BN and initialize it with the specified value."]
    #[doc = ""]
    #[doc = " @details The specified number of bytes is the minimal required bytes,"]
    #[doc = "          the number of words allocated will be automatically a multiple"]
    #[doc = "          of the configured word size."]
    #[doc = ""]
    #[doc = " @param[in] x            Pointer to a BN."]
    #[doc = ""]
    #[doc = " @param[in] nbytes       Number of bytes of x."]
    #[doc = ""]
    #[doc = " @param[in] value        Pointer to the value used to initialize the BN."]
    #[doc = ""]
    #[doc = " @param[in] value_nbytes Number of bytes of value."]
    #[doc = ""]
    #[doc = " @return                 Error code:"]
    #[doc = "                         - CX_OK on success"]
    #[doc = "                         - CX_BN_MEMORY_FULL"]
    #[doc = "                         - CX_BN_INVALID_PARAMETER_SIZE"]
    pub fn cx_bn_alloc_init(
        x: *mut cx_bn_t,
        nbytes: size_t,
        value: *const u8,
        value_nbytes: size_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Release a BN and give back its attached memory to the system."]
    #[doc = ""]
    #[doc = " @param[in] x BN to release. If NULL, nothing is done."]
    #[doc = ""]
    #[doc = " @return      Error code:"]
    #[doc = "              - CX_OK on success"]
    #[doc = "              - CX_BN_INVALID_PARAMETER_SIZE"]
    #[doc = "              - CX_BN_INVALID_PARAMETER_VALUE"]
    pub fn cx_bn_destroy(x: *mut cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Return the size in bytes of a BN."]
    #[doc = ""]
    #[doc = " @param[in]  x      BN index."]
    #[doc = ""]
    #[doc = " @param[out] nbytes Returned number of bytes."]
    #[doc = ""]
    #[doc = " @return            Error code:"]
    #[doc = "                    - CX_OK on success"]
    #[doc = "                    - CX_BN_INVALID_PARAMETER"]
    pub fn cx_bn_nbytes(x: cx_bn_t, nbytes: *mut size_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Initialize a BN with an unsigned value."]
    #[doc = ""]
    #[doc = " @param[in] x              BN index."]
    #[doc = ""]
    #[doc = " @param[in] value          Pointer to the value in big-endian order."]
    #[doc = ""]
    #[doc = " @param[in] value_nbytes   Number of bytes of the value."]
    #[doc = ""]
    #[doc = " @return                   Error code:"]
    #[doc = "                           - CX_OK on success"]
    #[doc = "                           - CX_BN_INVALID_PARAMETER_SIZE"]
    #[doc = "                           - CX_BN_INVALID_PARAMETER_VALUE"]
    pub fn cx_bn_init(x: cx_bn_t, value: *const u8, value_nbytes: size_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Generate a random number and store it in the given index."]
    #[doc = ""]
    #[doc = " @param[in] x BN index."]
    #[doc = ""]
    #[doc = " @return      Error code:"]
    #[doc = "              - CX_OK on success"]
    #[doc = "              - CX_BN_INVALID_PARAMETER_VALUE"]
    pub fn cx_bn_rand(x: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Copy the BN value."]
    #[doc = ""]
    #[doc = " @param[out] a BN destination index."]
    #[doc = ""]
    #[doc = " @param[in]  b BN source index."]
    #[doc = ""]
    #[doc = " @return       Error code:"]
    #[doc = "               - CX_OK on success"]
    #[doc = "               - CX_BN_INVALID_PARAMETER_SIZE"]
    #[doc = "               - CX_BN_INVALID_PARAMETER_VALUE"]
    pub fn cx_bn_copy(a: cx_bn_t, b: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Set the value of a BN with a 32-bit unsigned value."]
    #[doc = ""]
    #[doc = " @param[in] x BN index."]
    #[doc = ""]
    #[doc = " @param[in] n 32-bit value to be assigned."]
    #[doc = ""]
    #[doc = " @return      Error code:"]
    #[doc = "              - CX_OK on success"]
    #[doc = "              - CX_NOT_LOCKED"]
    #[doc = "              - CX_INVALID_PARAMETER"]
    pub fn cx_bn_set_u32(x: cx_bn_t, n: u32) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Get the 32-bit value corresponding to a BN."]
    #[doc = ""]
    #[doc = " @param[in]  x BN index."]
    #[doc = ""]
    #[doc = " @param[out] n Stored 32-bit unsigned value."]
    #[doc = ""]
    #[doc = " @return       Error code:"]
    #[doc = "               - CX_OK on success"]
    #[doc = "               - CX_NOT_LOCKED"]
    #[doc = "               - CX_INVALID_PARAMETER"]
    pub fn cx_bn_get_u32(x: cx_bn_t, n: *mut u32) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Store/Serialize a BN value as unsigned raw bytes in big-endian"]
    #[doc = " order."]
    #[doc = ""]
    #[doc = " @details Only the least significant *nbytes* bytes of the BN are serialized"]
    #[doc = "          If *nbytes* is greater than the BN size, *x* is serialized right"]
    #[doc = " aligned and zero left padded."]
    #[doc = ""]
    #[doc = " @param[in]  x       BN index."]
    #[doc = ""]
    #[doc = " @param[out] bytes   Buffer where to store the serialized number."]
    #[doc = ""]
    #[doc = " @param[in]  nbytes  Number of bytes to store into the buffer."]
    #[doc = ""]
    #[doc = " @return             Error code:"]
    #[doc = "                     - CX_OK on success"]
    #[doc = "                     - CX_BN_INVALID_PARAMETER_SIZE"]
    #[doc = "                     - CX_BN_INVALID_PARAMETER_VALUE"]
    pub fn cx_bn_export(x: cx_bn_t, bytes: *mut u8, nbytes: size_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Compare two BN values."]
    #[doc = ""]
    #[doc = " @param[in]  a    BN index to the first value to be compared."]
    #[doc = ""]
    #[doc = " @param[in]  b    BN index to the second value to be compared."]
    #[doc = ""]
    #[doc = " @param[out] diff Result of the comparison:"]
    #[doc = "                  - 0 if the numbers are equal."]
    #[doc = "                  - > 0 if the first number is greater than the second"]
    #[doc = "                  - < 0 if the first number is smaller than the second"]
    #[doc = ""]
    #[doc = " @return          Error code:"]
    #[doc = "                  - CX_OK on success"]
    #[doc = "                  - CX_NOT_LOCKED"]
    #[doc = "                  - CX_INVALID_PARAMETER"]
    pub fn cx_bn_cmp(a: cx_bn_t, b: cx_bn_t, diff: *mut cty::c_int) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Compare a BN value with an unsigned integer."]
    #[doc = ""]
    #[doc = " @param[in]  a    BN index to the value to be compared."]
    #[doc = ""]
    #[doc = " @param[in]  b    Integer to be compared."]
    #[doc = ""]
    #[doc = " @param[out] diff Result of the comparison:"]
    #[doc = "                  - 0 if the numbers are equal."]
    #[doc = "                  - > 0 if the BN value is greater"]
    #[doc = "                  - < 0 if the BN value is smaller"]
    #[doc = ""]
    #[doc = " @return          Error code:"]
    #[doc = "                  - CX_OK on success"]
    #[doc = "                  - CX_NOT_LOCKED"]
    #[doc = "                  - CX_INVALID_PARAMETER"]
    pub fn cx_bn_cmp_u32(a: cx_bn_t, b: u32, diff: *mut cty::c_int) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Test whether a BN value is odd."]
    #[doc = ""]
    #[doc = " @param[in]  n    BN index."]
    #[doc = ""]
    #[doc = " @param[out] odd  Boolean which indicates the parity of the BN value:"]
    #[doc = "                  - 1 if odd"]
    #[doc = "                  - 0 if even"]
    #[doc = ""]
    #[doc = " @return          Error code:"]
    #[doc = "                  - CX_OK on success"]
    #[doc = "                  - CX_NOT_LOCKED"]
    #[doc = "                  - CX_INVALID_PARAMETER"]
    pub fn cx_bn_is_odd(n: cx_bn_t, odd: *mut bool) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform the bitwise 'exclusive-OR' of two BN values."]
    #[doc = ""]
    #[doc = " @details *r* must be distinct from *a* and *b*."]
    #[doc = ""]
    #[doc = " @param[out] r BN index for the result."]
    #[doc = ""]
    #[doc = " @param[in]  a BN index of the first operand."]
    #[doc = ""]
    #[doc = " @param[in]  b BN index of the second operand."]
    #[doc = ""]
    #[doc = " @return       Error code:"]
    #[doc = "               - CX_OK on success"]
    #[doc = "               - CX_NOT_LOCKED"]
    #[doc = "               - CX_INVALID_PARAMETER"]
    pub fn cx_bn_xor(r: cx_bn_t, a: cx_bn_t, b: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform the bitwise 'OR' of two BN values."]
    #[doc = ""]
    #[doc = " @details *r* must be distinct from *a* and *b*."]
    #[doc = ""]
    #[doc = " @param[out] r BN index for the result."]
    #[doc = ""]
    #[doc = " @param[in]  a BN index of the first operand."]
    #[doc = ""]
    #[doc = " @param[in]  b BN index of the second operand."]
    #[doc = ""]
    #[doc = " @return       Error code:"]
    #[doc = "               - CX_OK on success"]
    #[doc = "               - CX_NOT_LOCKED"]
    #[doc = "               - CX_INVALID_PARAMETER"]
    pub fn cx_bn_or(r: cx_bn_t, a: cx_bn_t, b: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform the bitwise 'AND' of two BN values."]
    #[doc = ""]
    #[doc = " @details *r* must be distinct from *a* and *b*."]
    #[doc = ""]
    #[doc = " @param[out] r BN index for the result."]
    #[doc = ""]
    #[doc = " @param[in]  a BN index of the first operand."]
    #[doc = ""]
    #[doc = " @param[in]  b BN index of the second operand."]
    #[doc = ""]
    #[doc = " @return       Error code:"]
    #[doc = "               - CX_OK on success"]
    #[doc = "               - CX_NOT_LOCKED"]
    #[doc = "               - CX_INVALID_PARAMETER"]
    pub fn cx_bn_and(r: cx_bn_t, a: cx_bn_t, b: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Test the bit value at the specified index."]
    #[doc = ""]
    #[doc = " @details The BN value is in big endian order, thus the"]
    #[doc = "          position 0 corresponds to the least significant bit."]
    #[doc = ""]
    #[doc = " @param[in]  x    BN index."]
    #[doc = ""]
    #[doc = " @param[in]  pos  Position of the bit."]
    #[doc = ""]
    #[doc = " @param[out] set  Boolean which indicates the bit value"]
    #[doc = "                  - 1 if the bit is set"]
    #[doc = "                  - 0 otherwise"]
    #[doc = ""]
    #[doc = " @return          Error code:"]
    #[doc = "                  - CX_OK on success"]
    #[doc = "                  - CX_NOT_LOCKED"]
    #[doc = "                  - CX_INVALID_PARAMETER"]
    pub fn cx_bn_tst_bit(x: cx_bn_t, pos: u32, set: *mut bool) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Set the bit value at the specified index."]
    #[doc = ""]
    #[doc = " @details The BN value is in big endian order, thus the"]
    #[doc = "          position 0 corresponds to the least significant bit."]
    #[doc = ""]
    #[doc = " @param[in]  x    BN index."]
    #[doc = ""]
    #[doc = " @param[in]  pos  Position of the bit."]
    #[doc = ""]
    #[doc = " @return          Error code:"]
    #[doc = "                  - CX_OK on success"]
    #[doc = "                  - CX_NOT_LOCKED"]
    #[doc = "                  - CX_INVALID_PARAMETER"]
    pub fn cx_bn_set_bit(x: cx_bn_t, pos: u32) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Clear the bit value at the specified index."]
    #[doc = ""]
    #[doc = " @details The BN value is in big endian order, thus the"]
    #[doc = "          position 0 corresponds to the least significant bit."]
    #[doc = ""]
    #[doc = " @param[in]  x    BN index."]
    #[doc = ""]
    #[doc = " @param[in]  pos  Position of the bit."]
    #[doc = ""]
    #[doc = " @return          Error code:"]
    #[doc = "                  - CX_OK on success"]
    #[doc = "                  - CX_NOT_LOCKED"]
    #[doc = "                  - CX_INVALID_PARAMETER"]
    pub fn cx_bn_clr_bit(x: cx_bn_t, pos: u32) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform a right shift."]
    #[doc = ""]
    #[doc = " @param[in]  x  BN index."]
    #[doc = ""]
    #[doc = " @param[in]  n  Number of bits to shift."]
    #[doc = ""]
    #[doc = " @return        Error code:"]
    #[doc = "                - CX_OK on success"]
    #[doc = "                - CX_NOT_LOCKED"]
    #[doc = "                - CX_INVALID_PARAMETER"]
    pub fn cx_bn_shr(x: cx_bn_t, n: u32) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform a left shift."]
    #[doc = ""]
    #[doc = " @param[in]  x  BN index."]
    #[doc = ""]
    #[doc = " @param[in]  n  Number of bits to shift."]
    #[doc = ""]
    #[doc = " @return        Error code:"]
    #[doc = "                - CX_OK on success"]
    #[doc = "                - CX_NOT_LOCKED"]
    #[doc = "                - CX_INVALID_PARAMETER"]
    pub fn cx_bn_shl(x: cx_bn_t, n: u32) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Count the number of bits set to 1 of the BN value."]
    #[doc = ""]
    #[doc = " @param[in]  n      BN index."]
    #[doc = ""]
    #[doc = " @param[out] nbits  Number of bits set."]
    #[doc = ""]
    #[doc = " @return            Error code:"]
    #[doc = "                    - CX_OK on success"]
    #[doc = "                    - CX_NOT_LOCKED"]
    #[doc = "                    - CX_INVALID_PARAMETER"]
    pub fn cx_bn_cnt_bits(n: cx_bn_t, nbits: *mut u32) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform an addition **r = a + b**."]
    #[doc = ""]
    #[doc = " @details *r*, *a* and *b* shall have the same BN size."]
    #[doc = ""]
    #[doc = " @param[out] r BN index for the result."]
    #[doc = ""]
    #[doc = " @param[in]  a BN index of the first operand."]
    #[doc = ""]
    #[doc = " @param[in]  b BN index of the second operand."]
    #[doc = ""]
    #[doc = " @return       Error code:"]
    #[doc = "               - CX_OK or CX_CARRY on success"]
    #[doc = "               - CX_NOT_LOCKED"]
    #[doc = "               - CX_INVALID_PARAMETER"]
    pub fn cx_bn_add(r: cx_bn_t, a: cx_bn_t, b: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform a subtraction **r = a - b**."]
    #[doc = ""]
    #[doc = " @details *r*, *a* and *b* shall have the same BN size."]
    #[doc = ""]
    #[doc = " @param[out] r BN index for the result."]
    #[doc = ""]
    #[doc = " @param[in]  a BN index of the first operand."]
    #[doc = ""]
    #[doc = " @param[in]  b BN index of the second operand."]
    #[doc = ""]
    #[doc = " @return       Error code:"]
    #[doc = "               - CX_OK or CX_CARRY on success"]
    #[doc = "               - CX_NOT_LOCKED"]
    #[doc = "               - CX_INVALID_PARAMETER"]
    pub fn cx_bn_sub(r: cx_bn_t, a: cx_bn_t, b: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform a multiplication **r = a * b**."]
    #[doc = ""]
    #[doc = " @details *r*, *a* and *b* shall have the same BN size."]
    #[doc = ""]
    #[doc = " @param[out] r BN index for the result."]
    #[doc = ""]
    #[doc = " @param[in]  a BN index of the first operand."]
    #[doc = ""]
    #[doc = " @param[in]  b BN index of the second operand."]
    #[doc = ""]
    #[doc = " @return       Error code:"]
    #[doc = "               - CX_OK on success"]
    #[doc = "               - CX_NOT_LOCKED"]
    #[doc = "               - CX_INVALID_PARAMETER"]
    pub fn cx_bn_mul(r: cx_bn_t, a: cx_bn_t, b: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform a modular addition **r = a + b mod n**."]
    #[doc = ""]
    #[doc = " @details *r*, *a*, *b* and *n* shall have the same BN size."]
    #[doc = "          The values of *a* and *b* must be strictly smaller"]
    #[doc = "          than modulus value."]
    #[doc = ""]
    #[doc = " @param[out] r BN index for the result."]
    #[doc = ""]
    #[doc = " @param[in]  a BN index of the first operand."]
    #[doc = ""]
    #[doc = " @param[in]  b BN index of the second operand."]
    #[doc = ""]
    #[doc = " @param[in]  n BN index of the modulus."]
    #[doc = ""]
    #[doc = " @return       Error code:"]
    #[doc = "               - CX_OK on success"]
    #[doc = "               - CX_NOT_LOCKED"]
    #[doc = "               - CX_INVALID_PARAMETER"]
    #[doc = "               - CX_MEMORY_FULL"]
    pub fn cx_bn_mod_add(r: cx_bn_t, a: cx_bn_t, b: cx_bn_t, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform a modular subtraction **r = a - b mod n**."]
    #[doc = ""]
    #[doc = " @details *r*, *a*, *b* and *n* shall have the same BN size."]
    #[doc = "          The values of *a* and *b* must be strictly smaller"]
    #[doc = "          than modulus value."]
    #[doc = ""]
    #[doc = " @param[out] r BN index for the result."]
    #[doc = ""]
    #[doc = " @param[in]  a BN index of the first operand."]
    #[doc = ""]
    #[doc = " @param[in]  b BN index of the second operand."]
    #[doc = ""]
    #[doc = " @param[in]  n BN index of the modulus."]
    #[doc = ""]
    #[doc = " @return       Error code:"]
    #[doc = "               - CX_OK on success"]
    #[doc = "               - CX_NOT_LOCKED"]
    #[doc = "               - CX_INVALID_PARAMETER"]
    #[doc = "               - CX_MEMORY_FULL"]
    pub fn cx_bn_mod_sub(r: cx_bn_t, a: cx_bn_t, b: cx_bn_t, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform a modular multiplication **r = a * b mod n**."]
    #[doc = ""]
    #[doc = " @details *r*, *a*, *b* and *n* shall have the same BN size."]
    #[doc = "          The value of b must be strictly smaller"]
    #[doc = "          than modulus value."]
    #[doc = ""]
    #[doc = " @param[out] r BN index for the result."]
    #[doc = ""]
    #[doc = " @param[in]  a BN index of the first operand."]
    #[doc = ""]
    #[doc = " @param[in]  b BN index of the second operand."]
    #[doc = ""]
    #[doc = " @param[in]  n BN index of the modulus."]
    #[doc = ""]
    #[doc = " @return       Error code:"]
    #[doc = "               - CX_OK on success"]
    #[doc = "               - CX_NOT_LOCKED"]
    #[doc = "               - CX_INVALID_PARAMETER"]
    #[doc = "               - CX_INVALID_PARAMETER_VALUE"]
    #[doc = "               - CX_MEMORY_FULL"]
    pub fn cx_bn_mod_mul(r: cx_bn_t, a: cx_bn_t, b: cx_bn_t, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform a reduction **r = d mod n**."]
    #[doc = ""]
    #[doc = " @details *r* and *n* shall have the same BN size."]
    #[doc = ""]
    #[doc = " @param[out] r BN index for the result."]
    #[doc = ""]
    #[doc = " @param[in]  d BN index of the value to be reduced."]
    #[doc = ""]
    #[doc = " @param[in]  n BN index of the modulus."]
    #[doc = ""]
    #[doc = " @return       Error code:"]
    #[doc = "               - CX_OK on success"]
    #[doc = "               - CX_NOT_LOCKED"]
    #[doc = "               - CX_INVALID_PARAMETER"]
    #[doc = "               - CX_MEMORY_FULL"]
    pub fn cx_bn_reduce(r: cx_bn_t, d: cx_bn_t, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Compute *r* such that **r = a mod n** if *a* is a quadratic"]
    #[doc = " residue."]
    #[doc = ""]
    #[doc = " @details This returns an error if the given number is not a quadratic"]
    #[doc = " residue. *r*, *a* and *n* shall have the same BN size."]
    #[doc = ""]
    #[doc = " @param[out] r    BN index for the result."]
    #[doc = ""]
    #[doc = " @param[in]  a    BN index of the value to compute the quadratic residue."]
    #[doc = ""]
    #[doc = " @param[in]  n    BN index of the modulus."]
    #[doc = ""]
    #[doc = " @param[in]  sign Sign of the quadratic residue."]
    #[doc = ""]
    #[doc = " @return          Error code:"]
    #[doc = "                  - CX_OK on success"]
    #[doc = "                  - CX_NOT_LOCKED"]
    #[doc = "                  - CX_INVALID_PARAMETER"]
    #[doc = "                  - CX_MEMORY_FULL"]
    #[doc = "                  - CX_NO_RESIDUE"]
    pub fn cx_bn_mod_sqrt(r: cx_bn_t, a: cx_bn_t, n: cx_bn_t, sign: u32) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform a modular exponentiation **r = a^e mod n**."]
    #[doc = ""]
    #[doc = " @details *r*, *a* and *n* shall have the same BN size."]
    #[doc = "          *r*, *a* and *n* must be different."]
    #[doc = ""]
    #[doc = " @param[out] r BN index for the result."]
    #[doc = ""]
    #[doc = " @param[in]  a BN index of the base of the exponentiation."]
    #[doc = ""]
    #[doc = " @param[in]  e BN index of the exponent."]
    #[doc = ""]
    #[doc = " @param[in]  n BN index of the modulus."]
    #[doc = ""]
    #[doc = " @return       Error code:"]
    #[doc = "               - CX_OK on success"]
    #[doc = "               - CX_NOT_LOCKED"]
    #[doc = "               - CX_INVALID_PARAMETER"]
    #[doc = "               - CX_MEMORY_FULL"]
    pub fn cx_bn_mod_pow_bn(r: cx_bn_t, a: cx_bn_t, e: cx_bn_t, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform a modular exponentiation **r = a^e mod n**."]
    #[doc = ""]
    #[doc = " @details *r*, *a* and *n* shall have the same BN size."]
    #[doc = "          *r*, *a* and *n* must be different."]
    #[doc = ""]
    #[doc = " @param[out] r     BN index for the result."]
    #[doc = ""]
    #[doc = " @param[in]  a     BN index of the base of the exponentiation."]
    #[doc = ""]
    #[doc = " @param[in]  e     Pointer to the exponent."]
    #[doc = ""]
    #[doc = " @param[in]  e_len Length of the exponent buffer."]
    #[doc = ""]
    #[doc = " @param[in]  n     BN index of the modulus."]
    #[doc = ""]
    #[doc = " @return           Error code:"]
    #[doc = "                   - CX_OK on success"]
    #[doc = "                   - CX_NOT_LOCKED"]
    #[doc = "                   - CX_INVALID_PARAMETER"]
    #[doc = "                   - CX_MEMORY_FULL"]
    pub fn cx_bn_mod_pow(r: cx_bn_t, a: cx_bn_t, e: *const u8, e_len: u32, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform a modular exponentiation **r = a^e mod n**."]
    #[doc = ""]
    #[doc = " @details This fonction reuses the parameter *a* for intermediate"]
    #[doc = " computations, hence requires less memory. *r*, *a* and *n* shall have the"]
    #[doc = " same BN size. *r*, *a* and *n* must be different."]
    #[doc = ""]
    #[doc = " @param[out] r     BN index for the result."]
    #[doc = ""]
    #[doc = " @param[in]  a     BN index of the base of the exponentiation."]
    #[doc = "                   The BN value is modified during the"]
    #[doc = "                   computations."]
    #[doc = ""]
    #[doc = " @param[in]  e     Pointer to the exponent."]
    #[doc = ""]
    #[doc = " @param[in]  e_len Length of the exponent buffer."]
    #[doc = ""]
    #[doc = " @param[in]  n     BN index of the modulus."]
    #[doc = ""]
    #[doc = " @return           Error code:"]
    #[doc = "                   - CX_OK on success"]
    #[doc = "                   - CX_NOT_LOCKED"]
    #[doc = "                   - CX_INVALID_PARAMETER"]
    #[doc = "                   - CX_MEMORY_FULL"]
    pub fn cx_bn_mod_pow2(r: cx_bn_t, a: cx_bn_t, e: *const u8, e_len: u32, n: cx_bn_t)
        -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Compute the modular inverse **r = a^(-1) mod n**,"]
    #[doc = "          for a prime *n*."]
    #[doc = ""]
    #[doc = " @details *r*, *a* and *n* shall have the same BN size. *n* must be prime."]
    #[doc = ""]
    #[doc = " @param[out] r BN index for the result."]
    #[doc = ""]
    #[doc = " @param[in]  a BN index of the value to be inverted."]
    #[doc = ""]
    #[doc = " @param[in]  n BN index of the modulus."]
    #[doc = ""]
    #[doc = " @return       Error code:"]
    #[doc = "               - CX_OK on success"]
    #[doc = "               - CX_NOT_LOCKED"]
    #[doc = "               - CX_INVALID_PARAMETER"]
    #[doc = "               - CX_MEMORY_FULL"]
    pub fn cx_bn_mod_invert_nprime(r: cx_bn_t, a: cx_bn_t, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Compute the modular inverse **r = a^(-1) mod n**,"]
    #[doc = "          of a 32-bit value."]
    #[doc = ""]
    #[doc = " @details *r* and *n* shall have the same BN size."]
    #[doc = "          The parameters *n* is detroyed and contains zero"]
    #[doc = "          after the function returns."]
    #[doc = ""]
    #[doc = " @param[out] r BN index for the result."]
    #[doc = ""]
    #[doc = " @param[in]  a 32-bit value to be inverted."]
    #[doc = ""]
    #[doc = " @param[in]  n BN index of the modulus."]
    #[doc = ""]
    #[doc = " @return       Error code:"]
    #[doc = "               - CX_OK on success"]
    #[doc = "               - CX_NOT_LOCKED"]
    #[doc = "               - CX_INVALID_PARAMETER"]
    #[doc = "               - CX_MEMORY_FULL"]
    #[doc = "               - CX_INTERNAL_ERROR"]
    #[doc = "               - CX_NOT_INVERTIBLE"]
    pub fn cx_bn_mod_u32_invert(r: cx_bn_t, a: u32, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Allocate memory for the Montgomery context."]
    #[doc = ""]
    #[doc = " @param[in] ctx    Pointer to the Montogmery context."]
    #[doc = ""]
    #[doc = " @param[in] length BN size for the context fields."]
    #[doc = ""]
    #[doc = " @return           Error code:"]
    #[doc = "                   - CX_OK on success"]
    #[doc = "                   - CX_NOT_LOCKED"]
    #[doc = "                   - CX_MEMORY_FULL"]
    pub fn cx_mont_alloc(ctx: *mut cx_bn_mont_ctx_t, length: size_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Initialize a Montgomery context with the modulus."]
    #[doc = ""]
    #[doc = " @details Calculate and set up the second Montgomery constant."]
    #[doc = ""]
    #[doc = " @param[in] ctx Pointer to a Montgomery context."]
    #[doc = ""]
    #[doc = " @param[in] n   BN index of the modulus."]
    #[doc = ""]
    #[doc = " @return        Error code:"]
    #[doc = "                - CX_OK on success"]
    #[doc = "                - CX_NOT_LOCKED"]
    #[doc = "                - CX_INVALID_PARAMETER"]
    #[doc = "                - CX_MEMORY_FULL"]
    pub fn cx_mont_init(ctx: *mut cx_bn_mont_ctx_t, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Initialize a Montgomery context with the modulus and"]
    #[doc = "          the second Montgomery constant."]
    #[doc = ""]
    #[doc = " @details Set up the second Montgomery constant with the given"]
    #[doc = "          parameter."]
    #[doc = "          The caller should make sure that the given"]
    #[doc = "          second Montgomery constant is correct."]
    #[doc = ""]
    #[doc = " @param[in] ctx Pointer to a Montgomery context."]
    #[doc = ""]
    #[doc = " @param[in] n   BN index of the modulus."]
    #[doc = ""]
    #[doc = " @param[in] h   BN index of the pre calculated second Montgomery constant."]
    #[doc = ""]
    #[doc = " @return        Error code:"]
    #[doc = "                - CX_OK on success"]
    #[doc = "                - CX_NOT_LOCKED"]
    #[doc = "                - CX_INVALID_PARAMETER"]
    pub fn cx_mont_init2(ctx: *mut cx_bn_mont_ctx_t, n: cx_bn_t, h: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Compute the Montgomery representation of a BN value."]
    #[doc = ""]
    #[doc = " @details The context must be initialized."]
    #[doc = ""]
    #[doc = " @param[out] x   BN index for the result."]
    #[doc = ""]
    #[doc = " @param[in]  z   BN index of the value to convert into Montgomery"]
    #[doc = " representation."]
    #[doc = ""]
    #[doc = " @param[in]  ctx Pointer to the Montgomery context, initialized"]
    #[doc = "                 with the modulus and the second Montgomery constant."]
    #[doc = ""]
    #[doc = " @return         Error code:"]
    #[doc = "                 - CX_OK on success"]
    #[doc = "                 - CX_NOT_LOCKED"]
    #[doc = "                 - CX_INVALID_PARAMETER"]
    #[doc = "                 - CX_MEMORY_FULL"]
    pub fn cx_mont_to_montgomery(x: cx_bn_t, z: cx_bn_t, ctx: *const cx_bn_mont_ctx_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Compute the normal representation of a BN value"]
    #[doc = "          given a Montgomery representation."]
    #[doc = ""]
    #[doc = " @details The context must be initialized."]
    #[doc = ""]
    #[doc = " @param[out] x   BN index for the result."]
    #[doc = ""]
    #[doc = " @param[in]  z   BN index of the value to be converted."]
    #[doc = "                 The value should be in Montgomery representation."]
    #[doc = ""]
    #[doc = " @param[in]  ctx Pointer to the Montgomery context, initialized"]
    #[doc = "                 with the modulus and the second Montgomery constant."]
    #[doc = ""]
    #[doc = " @return         Error code:"]
    #[doc = "                 - CX_OK on success"]
    #[doc = "                 - CX_NOT_LOCKED"]
    #[doc = "                 - CX_INVALID_PARAMETER"]
    #[doc = "                 - CX_MEMORY_FULL"]
    pub fn cx_mont_from_montgomery(
        z: cx_bn_t,
        x: cx_bn_t,
        ctx: *const cx_bn_mont_ctx_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform a Montgomery multiplication."]
    #[doc = ""]
    #[doc = " @details The context must be initialized."]
    #[doc = ""]
    #[doc = " @param[out] r   BN index for the result."]
    #[doc = ""]
    #[doc = " @param[in]  a   BN index of the first operand in Montgomery representation."]
    #[doc = ""]
    #[doc = " @param[in]  b   BN index of the second operand in Montgomery representation."]
    #[doc = ""]
    #[doc = " @param[in]  ctx Pointer to the Montgomery context, initialized"]
    #[doc = "                 with the modulus and the second Montgomery constant."]
    #[doc = ""]
    #[doc = " @return         Error code:"]
    #[doc = "                 - CX_OK on success"]
    #[doc = "                 - CX_NOT_LOCKED"]
    #[doc = "                 - CX_INVALID_PARAMETER"]
    pub fn cx_mont_mul(
        r: cx_bn_t,
        a: cx_bn_t,
        b: cx_bn_t,
        ctx: *const cx_bn_mont_ctx_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform a modular exponentiation **r = a^e mod n**."]
    #[doc = ""]
    #[doc = " @details The context must be initialized. The BN value *a*"]
    #[doc = "          is in Montgomery representation."]
    #[doc = ""]
    #[doc = " @param[out] r     BN index for the result. The result is in"]
    #[doc = "                   Montgomery representation."]
    #[doc = ""]
    #[doc = " @param[in]  a     BN index of the exponentiation base in Montgomery"]
    #[doc = "                   representation."]
    #[doc = ""]
    #[doc = " @param[in]  e     Pointer to the exponent."]
    #[doc = ""]
    #[doc = " @param[in]  e_len Length of the exponent in bytes."]
    #[doc = ""]
    #[doc = " @param[in]  ctx   Pointer to the Montgomery context, initialized"]
    #[doc = "                   with the modulus and the second Montgomery constant."]
    #[doc = ""]
    #[doc = " @return           Error code:"]
    #[doc = "                   - CX_OK on success"]
    #[doc = "                   - CX_NOT_LOCKED"]
    #[doc = "                   - CX_INVALID_PARAMETER"]
    #[doc = "                   - CX_MEMORY_FULL"]
    pub fn cx_mont_pow(
        r: cx_bn_t,
        a: cx_bn_t,
        e: *const u8,
        e_len: u32,
        ctx: *const cx_bn_mont_ctx_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform a modular exponentiation **r = a^e mod n**."]
    #[doc = ""]
    #[doc = " @details The context must be initialized. The BN value *a*"]
    #[doc = "          is in Montgomery representation."]
    #[doc = ""]
    #[doc = " @param[out] r     BN index for the result. The result is in"]
    #[doc = "                   Montgomery representation."]
    #[doc = ""]
    #[doc = " @param[in]  a     BN index of the exponentiation base in Montgomery"]
    #[doc = "                   representation."]
    #[doc = ""]
    #[doc = " @param[in]  e     BN index of the exponent."]
    #[doc = ""]
    #[doc = " @param[in]  ctx   Pointer to the Montgomery context, initialized"]
    #[doc = "                   with the modulus and the second Montgomery constant."]
    #[doc = ""]
    #[doc = " @return           Error code:"]
    #[doc = "                   - CX_OK on success"]
    #[doc = "                   - CX_NOT_LOCKED"]
    #[doc = "                   - CX_INVALID_PARAMETER"]
    #[doc = "                   - CX_MEMORY_FULL"]
    pub fn cx_mont_pow_bn(
        r: cx_bn_t,
        a: cx_bn_t,
        e: cx_bn_t,
        ctx: *const cx_bn_mont_ctx_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Compute the modular inverse **r = a^(-1) mod n** for"]
    #[doc = "          a prime number *n*."]
    #[doc = ""]
    #[doc = " @details The context must be initialized."]
    #[doc = ""]
    #[doc = " @param[out] r   BN index for the result. The result is in"]
    #[doc = "                 Montgomery representation."]
    #[doc = ""]
    #[doc = " @param[in]  a   BN index of the value to be inverted. The value"]
    #[doc = "                 is in Montgomery representation."]
    #[doc = ""]
    #[doc = " @param[in]  ctx Pointer to the Montgomery context, initialized"]
    #[doc = "                 with the modulus and the second Montgomery constant"]
    #[doc = ""]
    #[doc = " @return         Error code:"]
    #[doc = "                 - CX_OK on success"]
    #[doc = "                 - CX_NOT_LOCKED"]
    #[doc = "                 - CX_INVALID_PARAMETER"]
    #[doc = "                 - CX_MEMORY_FULL"]
    pub fn cx_mont_invert_nprime(r: cx_bn_t, a: cx_bn_t, ctx: *const cx_bn_mont_ctx_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Test whether a BN value is a probable prime."]
    #[doc = ""]
    #[doc = " @param[in] n      BN index of the value."]
    #[doc = ""]
    #[doc = " @param[out] prime Boolean which indicates whether the number is a prime:"]
    #[doc = "                   - 1 if it is a prime"]
    #[doc = "                   - 0 otherwise"]
    #[doc = ""]
    #[doc = " @return           Error code:"]
    #[doc = "                   - CX_OK on success"]
    #[doc = "                   - CX_NOT_LOCKED"]
    #[doc = "                   - CX_INVALID_PARAMETER"]
    #[doc = "                   - CX_MEMORY_FULL"]
    pub fn cx_bn_is_prime(n: cx_bn_t, prime: *mut bool) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Return the first prime number after a"]
    #[doc = "          given BN value."]
    #[doc = ""]
    #[doc = " @param[in, out] n BN index of the value and the result."]
    #[doc = ""]
    #[doc = " @return           Error code:"]
    #[doc = "                   - CX_OK on success"]
    #[doc = "                   - CX_NOT_LOCKED"]
    #[doc = "                   - CX_INVALID_PARAMETER"]
    #[doc = "                   - CX_MEMORY_FULL"]
    #[doc = "                   - CX_OVERFLOW"]
    pub fn cx_bn_next_prime(n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief Generate a random number *r* in the range ]0,n[."]
    #[doc = ""]
    #[doc = " @details *r* is such that: **0 < r < n**."]
    #[doc = ""]
    #[doc = " @param[out] r BN index for the result."]
    #[doc = ""]
    #[doc = " @param[in]  n BN index of the upper bound."]
    #[doc = ""]
    #[doc = " @return       Error code:"]
    #[doc = "               - CX_OK on success"]
    #[doc = "               - CX_NOT_LOCKED"]
    #[doc = "               - CX_INVALID_PARAMETER"]
    #[doc = "               - CX_MEMORY_FULL"]
    pub fn cx_bn_rng(r: cx_bn_t, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_gf2_n_mul(
        bn_r: cx_bn_t,
        bn_a: cx_bn_t,
        bn_b: cx_bn_t,
        bn_n: cx_bn_t,
        bn_h: cx_bn_t,
    ) -> cx_err_t;
}
#[doc = " Undefined curve"]
pub const cx_curve_e_CX_CURVE_NONE: cx_curve_e = 0;
#[doc = " Low limit (not included) of Weierstrass curve ID"]
pub const cx_curve_e_CX_CURVE_WEIERSTRASS_START: cx_curve_e = 32;
#[doc = " Secp256k1"]
pub const cx_curve_e_CX_CURVE_SECP256K1: cx_curve_e = 33;
#[doc = " Secp256r1"]
pub const cx_curve_e_CX_CURVE_SECP256R1: cx_curve_e = 34;
#[doc = " Secp384r1"]
pub const cx_curve_e_CX_CURVE_SECP384R1: cx_curve_e = 35;
#[doc = " Secp521r1"]
pub const cx_curve_e_CX_CURVE_SECP521R1: cx_curve_e = 36;
#[doc = " BrainpoolP256t1"]
pub const cx_curve_e_CX_CURVE_BrainPoolP256T1: cx_curve_e = 49;
#[doc = " BrainpoolP256r1"]
pub const cx_curve_e_CX_CURVE_BrainPoolP256R1: cx_curve_e = 50;
#[doc = " BrainpoolP320t1"]
pub const cx_curve_e_CX_CURVE_BrainPoolP320T1: cx_curve_e = 51;
#[doc = " BrainpoolP320r1"]
pub const cx_curve_e_CX_CURVE_BrainPoolP320R1: cx_curve_e = 52;
#[doc = " BrainpoolP384t1"]
pub const cx_curve_e_CX_CURVE_BrainPoolP384T1: cx_curve_e = 53;
#[doc = " Brainpool384r1"]
pub const cx_curve_e_CX_CURVE_BrainPoolP384R1: cx_curve_e = 54;
#[doc = " BrainpoolP512t1"]
pub const cx_curve_e_CX_CURVE_BrainPoolP512T1: cx_curve_e = 55;
#[doc = " BrainpoolP512r1"]
pub const cx_curve_e_CX_CURVE_BrainPoolP512R1: cx_curve_e = 56;
#[doc = " BLS12-381 G1"]
pub const cx_curve_e_CX_CURVE_BLS12_381_G1: cx_curve_e = 57;
#[doc = " ANSSI FRP256"]
pub const cx_curve_e_CX_CURVE_FRP256V1: cx_curve_e = 65;
#[doc = " Stark"]
pub const cx_curve_e_CX_CURVE_Stark256: cx_curve_e = 81;
#[doc = " High limit (not included) of Weierstrass curve ID"]
pub const cx_curve_e_CX_CURVE_WEIERSTRASS_END: cx_curve_e = 111;
#[doc = " Low limit (not included) of  Twisted Edwards curve ID"]
pub const cx_curve_e_CX_CURVE_TWISTED_EDWARDS_START: cx_curve_e = 112;
#[doc = " Ed25519"]
pub const cx_curve_e_CX_CURVE_Ed25519: cx_curve_e = 113;
#[doc = " Ed448"]
pub const cx_curve_e_CX_CURVE_Ed448: cx_curve_e = 114;
#[doc = " High limit (not included) of Twisted Edwards curve ID"]
pub const cx_curve_e_CX_CURVE_TWISTED_EDWARDS_END: cx_curve_e = 127;
#[doc = " Low limit (not included) of Montgomery curve ID"]
pub const cx_curve_e_CX_CURVE_MONTGOMERY_START: cx_curve_e = 128;
#[doc = " Curve25519"]
pub const cx_curve_e_CX_CURVE_Curve25519: cx_curve_e = 129;
#[doc = " Curve448"]
pub const cx_curve_e_CX_CURVE_Curve448: cx_curve_e = 130;
#[doc = " High limit (not included) of Montgomery curve ID"]
pub const cx_curve_e_CX_CURVE_MONTGOMERY_END: cx_curve_e = 143;
#[doc = " List of supported elliptic curves"]
pub type cx_curve_e = cty::c_uint;
#[doc = " List of supported elliptic curves"]
pub use self::cx_curve_e as cx_curve_t;
#[doc = " @brief   Weierstrass curve defined by **y^3 = x^2 + a*x + b over GF(p)**."]
#[doc = ""]
#[doc = " @details See #CX_CURVE_HEADER for the structure members."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_curve_weierstrass_s {
    pub curve: cx_curve_t,
    pub bit_size: cty::c_uint,
    pub length: cty::c_uint,
    pub a: *const u8,
    pub b: *const u8,
    pub p: *const u8,
    pub Gx: *const u8,
    pub Gy: *const u8,
    pub n: *const u8,
    pub h: *const u8,
    pub Hn: *const u8,
    pub Hp: *const u8,
}
#[test]
fn bindgen_test_layout_cx_curve_weierstrass_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_curve_weierstrass_s>(),
        48usize,
        concat!("Size of: ", stringify!(cx_curve_weierstrass_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_curve_weierstrass_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_curve_weierstrass_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_weierstrass_s>())).curve as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cx_curve_weierstrass_s>())).bit_size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(bit_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_weierstrass_s>())).length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_weierstrass_s>())).a as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_weierstrass_s>())).b as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_weierstrass_s>())).p as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_weierstrass_s>())).Gx as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(Gx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_weierstrass_s>())).Gy as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(Gy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_weierstrass_s>())).n as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_weierstrass_s>())).h as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_weierstrass_s>())).Hn as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(Hn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_weierstrass_s>())).Hp as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(Hp)
        )
    );
}
impl Default for cx_curve_weierstrass_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief   Weierstrass curve defined by **y^3 = x^2 + a*x + b over GF(p)**."]
#[doc = ""]
#[doc = " @details See #CX_CURVE_HEADER for the structure members."]
pub type cx_curve_weierstrass_t = cx_curve_weierstrass_s;
#[doc = " @brief   Twisted Edwards curve defined by **a*x^2 + y^2 = 1 + d*x2*y2 over"]
#[doc = " GF(q)**."]
#[doc = ""]
#[doc = " @details See #CX_CURVE_HEADER for the structure members."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_curve_twisted_edwards_s {
    pub curve: cx_curve_t,
    pub bit_size: cty::c_uint,
    pub length: cty::c_uint,
    pub a: *const u8,
    pub b: *const u8,
    pub p: *const u8,
    pub Gx: *const u8,
    pub Gy: *const u8,
    pub n: *const u8,
    pub h: *const u8,
    pub Hn: *const u8,
    pub Hp: *const u8,
}
#[test]
fn bindgen_test_layout_cx_curve_twisted_edwards_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_curve_twisted_edwards_s>(),
        48usize,
        concat!("Size of: ", stringify!(cx_curve_twisted_edwards_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_curve_twisted_edwards_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_curve_twisted_edwards_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cx_curve_twisted_edwards_s>())).curve as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cx_curve_twisted_edwards_s>())).bit_size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(bit_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cx_curve_twisted_edwards_s>())).length as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_twisted_edwards_s>())).a as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_twisted_edwards_s>())).b as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_twisted_edwards_s>())).p as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_twisted_edwards_s>())).Gx as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(Gx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_twisted_edwards_s>())).Gy as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(Gy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_twisted_edwards_s>())).n as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_twisted_edwards_s>())).h as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_twisted_edwards_s>())).Hn as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(Hn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_twisted_edwards_s>())).Hp as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(Hp)
        )
    );
}
impl Default for cx_curve_twisted_edwards_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief   Twisted Edwards curve defined by **a*x^2 + y^2 = 1 + d*x2*y2 over"]
#[doc = " GF(q)**."]
#[doc = ""]
#[doc = " @details See #CX_CURVE_HEADER for the structure members."]
pub type cx_curve_twisted_edwards_t = cx_curve_twisted_edwards_s;
#[doc = " @brief   Montgomery curve defined by **B*y^2= x^3 + A*x^2 + x over GF(q)**."]
#[doc = ""]
#[doc = " @details See #CX_CURVE_HEADER for the structure members."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_curve_montgomery_s {
    pub curve: cx_curve_t,
    pub bit_size: cty::c_uint,
    pub length: cty::c_uint,
    pub a: *const u8,
    pub b: *const u8,
    pub p: *const u8,
    pub Gx: *const u8,
    pub Gy: *const u8,
    pub n: *const u8,
    pub h: *const u8,
    pub Hn: *const u8,
    pub Hp: *const u8,
}
#[test]
fn bindgen_test_layout_cx_curve_montgomery_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_curve_montgomery_s>(),
        48usize,
        concat!("Size of: ", stringify!(cx_curve_montgomery_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_curve_montgomery_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_curve_montgomery_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_montgomery_s>())).curve as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_montgomery_s>())).bit_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(bit_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_montgomery_s>())).length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_montgomery_s>())).a as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_montgomery_s>())).b as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_montgomery_s>())).p as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_montgomery_s>())).Gx as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(Gx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_montgomery_s>())).Gy as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(Gy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_montgomery_s>())).n as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_montgomery_s>())).h as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_montgomery_s>())).Hn as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(Hn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_montgomery_s>())).Hp as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(Hp)
        )
    );
}
impl Default for cx_curve_montgomery_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief   Montgomery curve defined by **B*y^2= x^3 + A*x^2 + x over GF(q)**."]
#[doc = ""]
#[doc = " @details See #CX_CURVE_HEADER for the structure members."]
pub type cx_curve_montgomery_t = cx_curve_montgomery_s;
#[doc = " @brief   Abstract type for elliptic curve domain."]
#[doc = ""]
#[doc = " @details See #CX_CURVE_HEADER for the structure members."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_curve_domain_s {
    pub curve: cx_curve_t,
    pub bit_size: cty::c_uint,
    pub length: cty::c_uint,
    pub a: *const u8,
    pub b: *const u8,
    pub p: *const u8,
    pub Gx: *const u8,
    pub Gy: *const u8,
    pub n: *const u8,
    pub h: *const u8,
    pub Hn: *const u8,
    pub Hp: *const u8,
}
#[test]
fn bindgen_test_layout_cx_curve_domain_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_curve_domain_s>(),
        48usize,
        concat!("Size of: ", stringify!(cx_curve_domain_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_curve_domain_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_curve_domain_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_domain_s>())).curve as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_domain_s>())).bit_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(bit_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_domain_s>())).length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_domain_s>())).a as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_domain_s>())).b as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_domain_s>())).p as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_domain_s>())).Gx as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(Gx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_domain_s>())).Gy as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(Gy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_domain_s>())).n as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_domain_s>())).h as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_domain_s>())).Hn as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(Hn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_domain_s>())).Hp as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(Hp)
        )
    );
}
impl Default for cx_curve_domain_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief   Abstract type for elliptic curve domain."]
#[doc = ""]
#[doc = " @details See #CX_CURVE_HEADER for the structure members."]
pub type cx_curve_domain_t = cx_curve_domain_s;
#[doc = " @brief Elliptic curve point."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ec_point_s {
    #[doc = "< Point's curve"]
    pub curve: cx_curve_t,
    #[doc = "< x-coordinate in affine representation"]
    pub x: cx_bn_t,
    #[doc = "< y-coordinate in affine representation"]
    pub y: cx_bn_t,
    #[doc = "< z-coordinate = 1 in affine representation"]
    pub z: cx_bn_t,
}
#[test]
fn bindgen_test_layout_cx_ec_point_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_ec_point_s>(),
        16usize,
        concat!("Size of: ", stringify!(cx_ec_point_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ec_point_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ec_point_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ec_point_s>())).curve as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ec_point_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ec_point_s>())).x as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ec_point_s),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ec_point_s>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ec_point_s),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ec_point_s>())).z as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ec_point_s),
            "::",
            stringify!(z)
        )
    );
}
impl Default for cx_ec_point_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Elliptic curve point."]
pub type cx_ecpoint_t = cx_ec_point_s;
#[doc = "< No parameter"]
pub const cx_curve_dom_param_s_CX_CURVE_PARAM_NONE: cx_curve_dom_param_s = 0;
#[doc = "< First coefficient of the curve"]
pub const cx_curve_dom_param_s_CX_CURVE_PARAM_A: cx_curve_dom_param_s = 1;
#[doc = "< Second coefficient of the curve"]
pub const cx_curve_dom_param_s_CX_CURVE_PARAM_B: cx_curve_dom_param_s = 2;
#[doc = "< Curve field"]
pub const cx_curve_dom_param_s_CX_CURVE_PARAM_Field: cx_curve_dom_param_s = 3;
#[doc = "< x-coordinate of the curve's generator"]
pub const cx_curve_dom_param_s_CX_CURVE_PARAM_Gx: cx_curve_dom_param_s = 4;
#[doc = "< y-coordinate of the curve's generator"]
pub const cx_curve_dom_param_s_CX_CURVE_PARAM_Gy: cx_curve_dom_param_s = 5;
#[doc = "< Order of the generator"]
pub const cx_curve_dom_param_s_CX_CURVE_PARAM_Order: cx_curve_dom_param_s = 6;
#[doc = "< Cofactor"]
pub const cx_curve_dom_param_s_CX_CURVE_PARAM_Cofactor: cx_curve_dom_param_s = 7;
#[doc = " @brief Identifiers of the domain parameters."]
pub type cx_curve_dom_param_s = cty::c_uint;
#[doc = " @brief Identifiers of the domain parameters."]
pub use self::cx_curve_dom_param_s as cx_curve_dom_param_t;
extern "C" {
    #[doc = " @brief   Return the bit length of each parameter of the curve."]
    #[doc = ""]
    #[doc = " @param[in] curve   Curve identifier."]
    #[doc = ""]
    #[doc = " @param[out] length Bit length of each parameter."]
    #[doc = ""]
    #[doc = " @return            Error code:"]
    #[doc = "                    - CX_OK on success"]
    #[doc = "                    - CX_EC_INVALID_CURVE"]
    pub fn cx_ecdomain_size(curve: cx_curve_t, length: *mut size_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Return the byte length of each parameter of the curve."]
    #[doc = ""]
    #[doc = " @param[in]  cv     Curve identifier."]
    #[doc = ""]
    #[doc = " @param[out] length Byte length of each parameter."]
    #[doc = ""]
    #[doc = " @return            Error code:"]
    #[doc = "                    - CX_OK on success"]
    #[doc = "                    - CX_EC_INVALID_CURVE"]
    pub fn cx_ecdomain_parameters_length(cv: cx_curve_t, length: *mut size_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Get a specific parameter of the curve."]
    #[doc = ""]
    #[doc = " @param[in]  cv    Curve identifier."]
    #[doc = ""]
    #[doc = " @param[in]  id    Parameter identifier."]
    #[doc = ""]
    #[doc = " @param[out] p     Buffer where to store the parameter."]
    #[doc = ""]
    #[doc = " @param[in]  p_len Length of the buffer."]
    #[doc = ""]
    #[doc = " @return           Error code:"]
    #[doc = "                   - CX_OK on success"]
    #[doc = "                   - CX_EC_INVALID_CURVE"]
    #[doc = "                   - CX_INVALID_PARAMETER"]
    pub fn cx_ecdomain_parameter(
        cv: cx_curve_t,
        id: cx_curve_dom_param_t,
        p: *mut u8,
        p_len: u32,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Store a specific parameter of the curve as a BN."]
    #[doc = ""]
    #[doc = " @param[in]  cv Curve identifier."]
    #[doc = ""]
    #[doc = " @param[in]  id Parameter identifier."]
    #[doc = ""]
    #[doc = " @param[out] p  BN where to store the parameter."]
    #[doc = ""]
    #[doc = " @return        Error code:"]
    #[doc = "                - CX_OK on success"]
    #[doc = "                - CX_EC_INVALID_CURVE"]
    #[doc = "                - CX_NOT_LOCKED"]
    #[doc = "                - CX_INVALID_PARAMETER"]
    #[doc = "                - CX_INVALID_PARAMETER_SIZE"]
    pub fn cx_ecdomain_parameter_bn(
        cv: cx_curve_t,
        id: cx_curve_dom_param_t,
        p: cx_bn_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Get the generator of the curve."]
    #[doc = ""]
    #[doc = " @param[in] cv   Curve identifier."]
    #[doc = ""]
    #[doc = " @param[out] Gx  Buffer to store the x-coordinate of the generator."]
    #[doc = ""]
    #[doc = " @param[out] Gy  Buffer to store the y-coordinate of the generator."]
    #[doc = ""]
    #[doc = " @param[in]  len Byte length of each coordinate."]
    #[doc = ""]
    #[doc = " @return         Error code:"]
    #[doc = "                 - CX_OK on success"]
    #[doc = "                 - CX_EC_INVALID_CURVE"]
    #[doc = "                 - CX_INVALID_PARAMETER"]
    pub fn cx_ecdomain_generator(cv: cx_curve_t, Gx: *mut u8, Gy: *mut u8, len: size_t)
        -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Get the generator of the curve and store it in the point structure."]
    #[doc = ""]
    #[doc = " @param[in]  cv Curve identifier."]
    #[doc = ""]
    #[doc = " @param[out] P  Pointer to the structure where to store the generator."]
    #[doc = ""]
    #[doc = " @return        Error code:"]
    #[doc = "                - CX_OK on success"]
    #[doc = "                - CX_EC_INVALID_CURVE"]
    #[doc = "                - CX_NOT_LOCKED"]
    #[doc = "                - CX_INVALID_PARAMETER"]
    #[doc = "                - CX_INVALID_PARAMETER_SIZE"]
    #[doc = "                - CX_EC_INVALID_POINT"]
    pub fn cx_ecdomain_generator_bn(cv: cx_curve_t, P: *mut cx_ecpoint_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Allocate memory for a point on the curve."]
    #[doc = ""]
    #[doc = " @param[in] P  Pointer to a point."]
    #[doc = ""]
    #[doc = " @param[in] cv Curve on which the point is defined."]
    #[doc = ""]
    #[doc = " @return       Error code:"]
    #[doc = "               - CX_OK on success"]
    #[doc = "               - CX_EC_INVALID_CURVE"]
    #[doc = "               - CX_NOT_LOCKED"]
    #[doc = "               - CX_INVALID_PARAMETER"]
    #[doc = "               - CX_MEMORY_FULL"]
    pub fn cx_ecpoint_alloc(P: *mut cx_ecpoint_t, cv: cx_curve_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Destroy a point on the curve."]
    #[doc = ""]
    #[doc = " @param[in] P Pointer to the point to destroy. If the pointer is NULL,"]
    #[doc = "              nothing is done."]
    #[doc = ""]
    #[doc = " @return      Error code:"]
    #[doc = "              - CX_OK on success"]
    #[doc = "              - CX_NOT_LOCKED"]
    #[doc = "              - CX_INVALID_PARAMETER"]
    #[doc = "              - CX_INTERNAL_ERROR"]
    pub fn cx_ecpoint_destroy(P: *mut cx_ecpoint_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Initialize a point on the curve."]
    #[doc = ""]
    #[doc = " @param[in] P     Pointer to the point to initialize."]
    #[doc = ""]
    #[doc = " @param[in] x     x-coordinate of the point. This must belong to the curve"]
    #[doc = " field."]
    #[doc = ""]
    #[doc = " @param[in] x_len Length of the x-coordinate. This must be at most equal to"]
    #[doc = " the curve's domain number of bytes."]
    #[doc = ""]
    #[doc = " @param[in] y     y-coordinate of the point. This must belong to the curve"]
    #[doc = " field."]
    #[doc = ""]
    #[doc = " @param[in] y_len Length of the y-coordinate. This must be at most equal to"]
    #[doc = " the curve's domain number of bytes."]
    #[doc = ""]
    #[doc = " @return          Error code:"]
    #[doc = "                  - CX_OK on success"]
    #[doc = "                  - CX_NOT_LOCKED"]
    #[doc = "                  - CX_INVALID_PARAMETER"]
    #[doc = "                  - CX_EC_INVALID_CURVE"]
    pub fn cx_ecpoint_init(
        P: *mut cx_ecpoint_t,
        x: *const u8,
        x_len: size_t,
        y: *const u8,
        y_len: size_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Initialize a point on the curve with the BN indexes of the"]
    #[doc = " coordinates."]
    #[doc = ""]
    #[doc = " @param[in] P Pointer to the point to initialize."]
    #[doc = ""]
    #[doc = " @param[in] x BN index of the x-coordinate. The coordinate must"]
    #[doc = "              belong to the base field."]
    #[doc = ""]
    #[doc = " @param[in] y BN index of the y-coordinate. The coordinate must"]
    #[doc = "              belong to the base field."]
    #[doc = ""]
    #[doc = " @return      Error code:"]
    #[doc = "              - CX_OK on success"]
    #[doc = "              - CX_NOT_LOCKED"]
    #[doc = "              - CX_INVALID_PARAMETER"]
    #[doc = "              - CX_EC_INVALID_CURVE"]
    pub fn cx_ecpoint_init_bn(P: *mut cx_ecpoint_t, x: cx_bn_t, y: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Export a point."]
    #[doc = ""]
    #[doc = " @details Fill two distinct buffers with the x-coordinate and the y-coordinate"]
    #[doc = "          of the point. If the point is not in affine representation, it will"]
    #[doc = "          be normalized first."]
    #[doc = ""]
    #[doc = " @param[in]  P     Pointer to the point to export."]
    #[doc = ""]
    #[doc = " @param[out] x     Buffer for the x-coordinate."]
    #[doc = ""]
    #[doc = " @param[in]  x_len Length of the *x* buffer."]
    #[doc = ""]
    #[doc = " @param[out] y     Buffer for the y-coordinate."]
    #[doc = ""]
    #[doc = " @param[in]  y_len Length of the *y* buffer."]
    #[doc = ""]
    #[doc = " @return           Error code:"]
    #[doc = "                   - CX_OK on success"]
    #[doc = "                   - CX_NOT_LOCKED"]
    #[doc = "                   - CX_INVALID_PARAMETER"]
    #[doc = "                   - CX_EC_INVALID_CURVE"]
    #[doc = "                   - CX_EC_INFINITE_POINT"]
    #[doc = "                   - CX_MEMORY_FULL"]
    pub fn cx_ecpoint_export(
        P: *const cx_ecpoint_t,
        x: *mut u8,
        x_len: size_t,
        y: *mut u8,
        y_len: size_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Export a point using BN indexes of the coordinates."]
    #[doc = ""]
    #[doc = " @param[in]  P Pointer to the point to export."]
    #[doc = ""]
    #[doc = " @param[out] x Pointer to the BN index of the x-coordinate."]
    #[doc = ""]
    #[doc = " @param[out] y Pointer to the BN index of the y-coordinate."]
    #[doc = ""]
    #[doc = " @return       Error code:"]
    #[doc = "               - CX_OK on success"]
    #[doc = "               - CX_NOT_LOCKED"]
    #[doc = "               - CX_INVALID_PARAMETER"]
    #[doc = "               - CX_EC_INVALID_CURVE"]
    #[doc = "               - CX_EC_INFINITE_POINT"]
    #[doc = "               - CX_MEMORY_FULL"]
    pub fn cx_ecpoint_export_bn(
        P: *const cx_ecpoint_t,
        x: *mut cx_bn_t,
        y: *mut cx_bn_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Compute the compressed form of a point."]
    #[doc = ""]
    #[doc = " @details The compressed form depends on the curve type."]
    #[doc = "          For a Weierstrass or a Montgomery curve, the"]
    #[doc = "          compressed form consists of the x-coordinate and"]
    #[doc = "          a prefix. For a Twisted Edwards curve the compressed"]
    #[doc = "          form consists of a y-coordinate and a prefix."]
    #[doc = ""]
    #[doc = " @param[in]  P Pointer to the point to be compressed."]
    #[doc = ""]
    #[doc = " @param[out] xy_compressed     Buffer to hold the compressed"]
    #[doc = "                               coordinate."]
    #[doc = ""]
    #[doc = " @param[in]  xy_compressed_len Length of the compressed coordinate in bytes."]
    #[doc = "                               This should be equal to twice of the length of"]
    #[doc = " one coordinate plus one byte for the prefix."]
    #[doc = ""]
    #[doc = " @param[out] sign              Pointer to the sign of the hidden coordinate:"]
    #[doc = "                               correspond to the least significant bit of the"]
    #[doc = "                               y-coordinate for a Weierstrass or Montgomery"]
    #[doc = " curve and of the x-coordinate for a Twisted Edwards curve."]
    #[doc = ""]
    #[doc = " @return                       Error code:"]
    #[doc = "                               - CX_OK on success"]
    #[doc = "                               - CX_NOT_LOCKED"]
    #[doc = "                               - CX_INVALID_PARAMETER"]
    #[doc = "                               - CX_EC_INVALID_CURVE"]
    #[doc = "                               - CX_EC_INFINITE_POINT"]
    #[doc = "                               - CX_MEMORY_FULL"]
    pub fn cx_ecpoint_compress(
        P: *const cx_ecpoint_t,
        xy_compressed: *mut u8,
        xy_compressed_len: size_t,
        sign: *mut u32,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Compute the affine coordinates of a point given its compressed form."]
    #[doc = ""]
    #[doc = " @param[out] P Pointer to the point."]
    #[doc = ""]
    #[doc = " @param[in]  xy_compressed     Pointer to the buffer holding the compressed"]
    #[doc = "                               coordinate."]
    #[doc = ""]
    #[doc = " @param[in]  xy_compressed_len Length of the compressed coordinate in bytes."]
    #[doc = "                               This should be equal to twice of the length of"]
    #[doc = " one coordinate plus one byte for the prefix."]
    #[doc = ""]
    #[doc = " @param[in]  sign              Sign of the coordinate to recover."]
    #[doc = ""]
    #[doc = " @return                       Error code:"]
    #[doc = "                               - CX_OK on success"]
    #[doc = "                               - CX_NOT_LOCKED"]
    #[doc = "                               - CX_INVALID_PARAMETER"]
    #[doc = "                               - CX_EC_INVALID_CURVE"]
    #[doc = "                               - CX_MEMORY_FULL"]
    #[doc = "                               - CX_NO_RESIDUE"]
    #[doc = ""]
    pub fn cx_ecpoint_decompress(
        P: *mut cx_ecpoint_t,
        xy_compressed: *const u8,
        xy_compressed_len: size_t,
        sign: u32,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Add two points on a curve."]
    #[doc = ""]
    #[doc = " @details Each point should not be the point at infinity."]
    #[doc = "          If one of the point is the point at infinity then"]
    #[doc = "          the function returns a CX_EC_INFINITE_POINT error."]
    #[doc = ""]
    #[doc = " @param[out] R Pointer to the result point."]
    #[doc = ""]
    #[doc = " @param[in]  P Pointer to the first point to add."]
    #[doc = "               The point must be on the curve."]
    #[doc = ""]
    #[doc = " @param[in]  Q Pointer to the second point to add."]
    #[doc = "               The point must be on the curve."]
    #[doc = ""]
    #[doc = " @return       Error code:"]
    #[doc = "               - CX_OK on success"]
    #[doc = "               - CX_NOT_LOCKED"]
    #[doc = "               - CX_INVALID_PARAMETER"]
    #[doc = "               - CX_EC_INVALID_CURVE"]
    #[doc = "               - CX_EC_INVALID_POINT"]
    #[doc = "               - CX_EC_INFINITE_POINT"]
    #[doc = "               - CX_MEMORY_FULL"]
    pub fn cx_ecpoint_add(
        R: *mut cx_ecpoint_t,
        P: *const cx_ecpoint_t,
        Q: *const cx_ecpoint_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Compute the opposite of a point."]
    #[doc = ""]
    #[doc = " @details The point should not be the point at infinity,"]
    #[doc = "          otherwise the function returns a CX_EC_INFINITE_POINT"]
    #[doc = "          error."]
    #[doc = ""]
    #[doc = " @param[in, out] P Pointer to a point of the curve."]
    #[doc = "                   and will hold the result."]
    #[doc = ""]
    #[doc = " @return           Error code:"]
    #[doc = "                   - CX_OK on success"]
    #[doc = "                   - CX_NOT_LOCKED"]
    #[doc = "                   - CX_INVALID_PARAMETER"]
    #[doc = "                   - CX_EC_INVALID_CURVE"]
    #[doc = "                   - CX_EC_INVALID_POINT"]
    #[doc = "                   - CX_MEMORY_FULL"]
    #[doc = "                   - CX_EC_INFINITE_POINT"]
    pub fn cx_ecpoint_neg(P: *mut cx_ecpoint_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform a secure scalar multiplication."]
    #[doc = ""]
    #[doc = " @param[in, out] P     Pointer to a point on a curve. This will hold the"]
    #[doc = " result."]
    #[doc = ""]
    #[doc = " @param[in]      k     Pointer to the scalar. The scalar is an integer at"]
    #[doc = " least equal to 0 and at most equal to the order of the curve minus 1."]
    #[doc = ""]
    #[doc = " @param[in]      k_len Length of the scalar. This should be equal to the"]
    #[doc = " domain length."]
    #[doc = ""]
    #[doc = " @return               Error code:"]
    #[doc = "                       - CX_OK on success"]
    #[doc = "                       - CX_NOT_LOCKED"]
    #[doc = "                       - CX_INVALID_PARAMETER"]
    #[doc = "                       - CX_EC_INVALID_POINT"]
    #[doc = "                       - CX_EC_INVALID_CURVE"]
    #[doc = "                       - CX_EC_INFINITE_POINT"]
    #[doc = "                       - CX_MEMORY_FULL"]
    pub fn cx_ecpoint_rnd_scalarmul(P: *mut cx_ecpoint_t, k: *const u8, k_len: size_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform a secure scalar multiplication given the BN index of the"]
    #[doc = " scalar."]
    #[doc = ""]
    #[doc = " @param[in, out] P    Pointer to a point on a curve. This will hold the"]
    #[doc = " result."]
    #[doc = ""]
    #[doc = " @param[in]      bn_k BN index of the scalar. The scalar is an integer at"]
    #[doc = " least equal to 0 and at most equal to the order of the curve minus 1."]
    #[doc = ""]
    #[doc = " @return           Error code:"]
    #[doc = "                   - CX_OK on success"]
    #[doc = "                   - CX_NOT_LOCKED"]
    #[doc = "                   - CX_INVALID_PARAMETER"]
    #[doc = "                   - CX_EC_INVALID_POINT"]
    #[doc = "                   - CX_EC_INVALID_CURVE"]
    #[doc = "                   - CX_EC_INFINITE_POINT"]
    #[doc = "                   - CX_MEMORY_FULL"]
    pub fn cx_ecpoint_rnd_scalarmul_bn(P: *mut cx_ecpoint_t, bn_k: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform a secure scalar multiplication with a fixed scalar length."]
    #[doc = ""]
    #[doc = " @param[in, out] P     Pointer to a point on a curve. This will hold the"]
    #[doc = " result."]
    #[doc = ""]
    #[doc = " @param[in]      k     Pointer to the scalar. The scalar is an integer at"]
    #[doc = " least equal to 0 and at most equal to the order of the curve minus 1."]
    #[doc = ""]
    #[doc = " @param[in]      k_len Length of the scalar. This should be equal to the"]
    #[doc = " domain length."]
    #[doc = ""]
    #[doc = " @return               Error code:"]
    #[doc = "                       - CX_OK on success"]
    #[doc = "                       - CX_NOT_LOCKED"]
    #[doc = "                       - CX_INVALID_PARAMETER"]
    #[doc = "                       - CX_EC_INVALID_POINT"]
    #[doc = "                       - CX_EC_INVALID_CURVE"]
    #[doc = "                       - CX_EC_INFINITE_POINT"]
    #[doc = "                       - CX_MEMORY_FULL"]
    pub fn cx_ecpoint_rnd_fixed_scalarmul(
        P: *mut cx_ecpoint_t,
        k: *const u8,
        k_len: size_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform a scalar multiplication."]
    #[doc = ""]
    #[doc = " @details This should be called only for non critical purposes."]
    #[doc = ""]
    #[doc = " @param[in, out] P      Pointer to a point on a curve. This will hold the"]
    #[doc = " result."]
    #[doc = ""]
    #[doc = " @param[in]      k      Pointer to the scalar. The scalar is an integer at"]
    #[doc = " least equal to 0 and at most equal to the order of the curve minus 1."]
    #[doc = ""]
    #[doc = " @param[in]      k_len  Length of the scalar."]
    #[doc = ""]
    #[doc = " @return                Error code:"]
    #[doc = "                        - CX_OK on success"]
    #[doc = "                        - CX_NOT_LOCKED"]
    #[doc = "                        - CX_INVALID_PARAMETER"]
    #[doc = "                        - CX_EC_INVALID_POINT"]
    #[doc = "                        - CX_EC_INVALID_CURVE"]
    #[doc = "                        - CX_EC_INFINITE_POINT"]
    #[doc = "                        - CX_MEMORY_FULL"]
    pub fn cx_ecpoint_scalarmul(P: *mut cx_ecpoint_t, k: *const u8, k_len: size_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform a scalar multiplication given the BN index of the scalar."]
    #[doc = ""]
    #[doc = " @details This should be called only for non critical purposes."]
    #[doc = ""]
    #[doc = " @param[in, out] P    Pointer to a point on a curve. This will hold the"]
    #[doc = " result."]
    #[doc = ""]
    #[doc = " @param[in]      bn_k BN index of the scalar. The scalar is an integer at"]
    #[doc = " least equal to 0 and at most equal to the order of the curve minus 1."]
    #[doc = ""]
    #[doc = " @return              Error code:"]
    #[doc = "                      - CX_OK on success"]
    #[doc = "                      - CX_NOT_LOCKED"]
    #[doc = "                      - CX_INVALID_PARAMETER"]
    #[doc = "                      - CX_EC_INVALID_POINT"]
    #[doc = "                      - CX_EC_INVALID_CURVE"]
    #[doc = "                      - CX_EC_INFINITE_POINT"]
    #[doc = "                      - CX_MEMORY_FULL"]
    pub fn cx_ecpoint_scalarmul_bn(P: *mut cx_ecpoint_t, bn_k: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform a double scalar multiplication."]
    #[doc = ""]
    #[doc = " @details This implements the Straus-Shamir algorithm for computing **R = [k]P"]
    #[doc = " + [r]Q**. This should be used only for non-secret computations."]
    #[doc = ""]
    #[doc = " @param[out] R     Pointer to the result."]
    #[doc = ""]
    #[doc = " @param[in]  P     Pointer to the first point."]
    #[doc = ""]
    #[doc = " @param[in]  Q     Pointer to the second point."]
    #[doc = ""]
    #[doc = " @param[in]  k     Pointer to the first scalar."]
    #[doc = ""]
    #[doc = " @param[in]  k_len Length of the first scalar."]
    #[doc = ""]
    #[doc = " @param[in]  r     Pointer to the second scalar."]
    #[doc = ""]
    #[doc = " @param[in]  r_len Length of the second scalar."]
    #[doc = ""]
    #[doc = " @return           Error code:"]
    #[doc = "                   - CX_OK on success"]
    #[doc = "                   - CX_NOT_LOCKED"]
    #[doc = "                   - CX_INVALID_PARAMETER"]
    #[doc = "                   - CX_EC_INVALID_POINT"]
    #[doc = "                   - CX_EC_INVALID_CURVE"]
    #[doc = "                   - CX_MEMORY_FULL"]
    #[doc = "                   - CX_EC_INFINITE_POINT"]
    pub fn cx_ecpoint_double_scalarmul(
        R: *mut cx_ecpoint_t,
        P: *mut cx_ecpoint_t,
        Q: *mut cx_ecpoint_t,
        k: *const u8,
        k_len: size_t,
        r: *const u8,
        r_len: size_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform a double scalar multiplication given the BN indexes of the"]
    #[doc = " scalars."]
    #[doc = ""]
    #[doc = " @details This implements the Straus-Shamir algorithm for computing **R = [k]P"]
    #[doc = " + [r]Q**. This should be used only for non-secret computations."]
    #[doc = ""]
    #[doc = " @param[out] R     Pointer to the result."]
    #[doc = ""]
    #[doc = " @param[in]  P     Pointer to the first point."]
    #[doc = ""]
    #[doc = " @param[in]  Q     Pointer to the second point."]
    #[doc = ""]
    #[doc = " @param[in]  bn_k  BN index of the first scalar."]
    #[doc = ""]
    #[doc = " @param[in]  bn_r  BN index of the second scalar."]
    #[doc = ""]
    #[doc = " @return           Error code:"]
    #[doc = "                  - CX_OK on success"]
    #[doc = "                  - CX_NOT_LOCKED"]
    #[doc = "                  - CX_INVALID_PARAMETER"]
    #[doc = "                  - CX_EC_INVALID_POINT"]
    #[doc = "                  - CX_EC_INVALID_CURVE"]
    #[doc = "                  - CX_MEMORY_FULL"]
    #[doc = "                  - CX_EC_INFINITE_POINT"]
    pub fn cx_ecpoint_double_scalarmul_bn(
        R: *mut cx_ecpoint_t,
        P: *mut cx_ecpoint_t,
        Q: *mut cx_ecpoint_t,
        bn_k: cx_bn_t,
        bn_r: cx_bn_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Compare two points on the same curve."]
    #[doc = ""]
    #[doc = " @param[in]  P        First point to compare."]
    #[doc = ""]
    #[doc = " @param[in]  Q        Second point to compare."]
    #[doc = ""]
    #[doc = " @param[out] is_equal Boolean which indicates whether the two points are equal"]
    #[doc = " or not:"]
    #[doc = "                      - 1 if the points are equal"]
    #[doc = "                      - 0 otherwise"]
    #[doc = ""]
    #[doc = " @return              Error code:"]
    #[doc = "                      - CX_OK on success"]
    #[doc = "                      - CX_NOT_LOCKED"]
    #[doc = "                      - CX_INVALID_PARAMETER"]
    #[doc = "                      - CX_EC_INVALID_CURVE"]
    #[doc = "                      - CX_EC_INFINITE_POINT"]
    #[doc = "                      - CX_MEMORY_FULL"]
    pub fn cx_ecpoint_cmp(
        P: *const cx_ecpoint_t,
        Q: *const cx_ecpoint_t,
        is_equal: *mut bool,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Check if a given point is on the curve."]
    #[doc = ""]
    #[doc = " @param[in]  R           Pointer to the point to check."]
    #[doc = ""]
    #[doc = " @param[out] is_on_curve Boolean which indicates whether the point is on the"]
    #[doc = " curve or not:"]
    #[doc = "                         - 1 if the point is on the curve"]
    #[doc = "                         - 0 otherwise"]
    #[doc = ""]
    #[doc = " @return                 Error code:"]
    #[doc = "                         - CX_OK on success"]
    #[doc = "                         - CX_NOT_LOCKED"]
    #[doc = "                         - CX_INVALID_PARAMETER"]
    #[doc = "                         - CX_EC_INVALID_CURVE"]
    #[doc = "                         - CX_EC_INFINITE_POINT"]
    #[doc = "                         - CX_MEMORY_FULL"]
    pub fn cx_ecpoint_is_on_curve(R: *const cx_ecpoint_t, is_on_curve: *mut bool) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Check if a given point is the point at infinity."]
    #[doc = ""]
    #[doc = " @details The point at infinity has a z-coordinate equal to 0."]
    #[doc = ""]
    #[doc = " @param[in]  R              Pointer to the point to check."]
    #[doc = ""]
    #[doc = " @param[out] is_at_infinity Boolean which indicates whether the point is at"]
    #[doc = " infinity or not:"]
    #[doc = "                            - 1 if the point is at infinity"]
    #[doc = "                            - 0 otherwise"]
    #[doc = ""]
    #[doc = " @return                    Error code:"]
    #[doc = "                            - CX_OK on success"]
    #[doc = "                            - CX_NOT_LOCKED"]
    #[doc = "                            - CX_INVALID_PARAMETER"]
    #[doc = "                            - CX_EC_INVALID_CURVE"]
    pub fn cx_ecpoint_is_at_infinity(R: *const cx_ecpoint_t, is_at_infinity: *mut bool)
        -> cx_err_t;
}
#[doc = " Elliptic Curve public key"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_public_key_s {
    #[doc = "< Curve identifier"]
    pub curve: cx_curve_t,
    #[doc = "< Public key length in bytes"]
    pub W_len: size_t,
    #[doc = "< Public key value starting at offset 0"]
    pub W: [u8; 1usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_public_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_public_key_s>(),
        12usize,
        concat!("Size of: ", stringify!(cx_ecfp_public_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_public_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_public_key_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ecfp_public_key_s>())).curve as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_public_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ecfp_public_key_s>())).W_len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_public_key_s),
            "::",
            stringify!(W_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ecfp_public_key_s>())).W as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_public_key_s),
            "::",
            stringify!(W)
        )
    );
}
impl Default for cx_ecfp_public_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Elliptic Curve private key"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_private_key_s {
    #[doc = "< Curve identifier"]
    pub curve: cx_curve_t,
    #[doc = "< Private key length in bytes"]
    pub d_len: size_t,
    #[doc = "< Private key value starting at offset 0"]
    pub d: [u8; 1usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_private_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_private_key_s>(),
        12usize,
        concat!("Size of: ", stringify!(cx_ecfp_private_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_private_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_private_key_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ecfp_private_key_s>())).curve as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_private_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ecfp_private_key_s>())).d_len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_private_key_s),
            "::",
            stringify!(d_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ecfp_private_key_s>())).d as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_private_key_s),
            "::",
            stringify!(d)
        )
    );
}
impl Default for cx_ecfp_private_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Up to 256-bit Elliptic Curve public key"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_256_public_key_s {
    #[doc = "< Curve identifier"]
    pub curve: cx_curve_t,
    #[doc = "< Public key length in bytes"]
    pub W_len: size_t,
    #[doc = "< Public key value starting at offset 0"]
    pub W: [u8; 65usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_256_public_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_256_public_key_s>(),
        76usize,
        concat!("Size of: ", stringify!(cx_ecfp_256_public_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_256_public_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_256_public_key_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ecfp_256_public_key_s>())).curve as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_256_public_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ecfp_256_public_key_s>())).W_len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_256_public_key_s),
            "::",
            stringify!(W_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ecfp_256_public_key_s>())).W as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_256_public_key_s),
            "::",
            stringify!(W)
        )
    );
}
impl Default for cx_ecfp_256_public_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Up to 256-bit Elliptic Curve private key"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_256_private_key_s {
    #[doc = "< Curve identifier"]
    pub curve: cx_curve_t,
    #[doc = "< Private key length in bytes"]
    pub d_len: size_t,
    #[doc = "< Private key value starting at offset 0"]
    pub d: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_256_private_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_256_private_key_s>(),
        40usize,
        concat!("Size of: ", stringify!(cx_ecfp_256_private_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_256_private_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_256_private_key_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cx_ecfp_256_private_key_s>())).curve as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_256_private_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cx_ecfp_256_private_key_s>())).d_len as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_256_private_key_s),
            "::",
            stringify!(d_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ecfp_256_private_key_s>())).d as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_256_private_key_s),
            "::",
            stringify!(d)
        )
    );
}
impl Default for cx_ecfp_256_private_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Up to 256-bit Elliptic Curve extended private key"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_256_extended_private_key_s {
    #[doc = "< Curve identifier"]
    pub curve: cx_curve_t,
    #[doc = "< Public key length in bytes"]
    pub d_len: size_t,
    #[doc = "< Public key value starting at offset 0"]
    pub d: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_256_extended_private_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_256_extended_private_key_s>(),
        72usize,
        concat!("Size of: ", stringify!(cx_ecfp_256_extended_private_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_256_extended_private_key_s>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cx_ecfp_256_extended_private_key_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cx_ecfp_256_extended_private_key_s>())).curve as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_256_extended_private_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cx_ecfp_256_extended_private_key_s>())).d_len as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_256_extended_private_key_s),
            "::",
            stringify!(d_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cx_ecfp_256_extended_private_key_s>())).d as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_256_extended_private_key_s),
            "::",
            stringify!(d)
        )
    );
}
impl Default for cx_ecfp_256_extended_private_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Up to 256-bit Elliptic Curve public key"]
pub type cx_ecfp_256_public_key_t = cx_ecfp_256_public_key_s;
#[doc = " Up to 256-bit Elliptic Curve private key"]
pub type cx_ecfp_256_private_key_t = cx_ecfp_256_private_key_s;
#[doc = " Up to 256-bit Elliptic Curve extended private key"]
pub type cx_ecfp_256_extended_private_key_t = cx_ecfp_256_extended_private_key_s;
#[doc = " Up to 256-bit Elliptic Curve public key"]
pub type cx_ecfp_public_key_t = cx_ecfp_256_public_key_s;
#[doc = " Up to 256-bit Elliptic Curve private key"]
pub type cx_ecfp_private_key_t = cx_ecfp_256_private_key_s;
#[doc = " Up to 384-bit Elliptic Curve public key"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_384_public_key_s {
    #[doc = "< Curve identifier"]
    pub curve: cx_curve_t,
    #[doc = "< Public key length in bytes"]
    pub W_len: size_t,
    #[doc = "< Public key value starting at offset 0"]
    pub W: [u8; 97usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_384_public_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_384_public_key_s>(),
        108usize,
        concat!("Size of: ", stringify!(cx_ecfp_384_public_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_384_public_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_384_public_key_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ecfp_384_public_key_s>())).curve as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_384_public_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ecfp_384_public_key_s>())).W_len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_384_public_key_s),
            "::",
            stringify!(W_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ecfp_384_public_key_s>())).W as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_384_public_key_s),
            "::",
            stringify!(W)
        )
    );
}
impl Default for cx_ecfp_384_public_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Up to 384-bit Elliptic Curve private key"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_384_private_key_s {
    #[doc = "< Curve identifier"]
    pub curve: cx_curve_t,
    #[doc = "< Private key length in bytes"]
    pub d_len: size_t,
    #[doc = "< Private key value starting at offset 0"]
    pub d: [u8; 48usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_384_private_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_384_private_key_s>(),
        56usize,
        concat!("Size of: ", stringify!(cx_ecfp_384_private_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_384_private_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_384_private_key_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cx_ecfp_384_private_key_s>())).curve as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_384_private_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cx_ecfp_384_private_key_s>())).d_len as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_384_private_key_s),
            "::",
            stringify!(d_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ecfp_384_private_key_s>())).d as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_384_private_key_s),
            "::",
            stringify!(d)
        )
    );
}
impl Default for cx_ecfp_384_private_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Up to 384-bit Elliptic Curve private key"]
pub type cx_ecfp_384_private_key_t = cx_ecfp_384_private_key_s;
#[doc = " Up to 384-bit Elliptic Curve public key"]
pub type cx_ecfp_384_public_key_t = cx_ecfp_384_public_key_s;
#[doc = " Up to 512-bit Elliptic Curve public key"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_512_public_key_s {
    #[doc = "< Curve identifier"]
    pub curve: cx_curve_t,
    #[doc = "< Public key length in bytes"]
    pub W_len: size_t,
    #[doc = "< Public key value starting at offset 0"]
    pub W: [u8; 129usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_512_public_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_512_public_key_s>(),
        140usize,
        concat!("Size of: ", stringify!(cx_ecfp_512_public_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_512_public_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_512_public_key_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ecfp_512_public_key_s>())).curve as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_512_public_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ecfp_512_public_key_s>())).W_len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_512_public_key_s),
            "::",
            stringify!(W_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ecfp_512_public_key_s>())).W as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_512_public_key_s),
            "::",
            stringify!(W)
        )
    );
}
impl Default for cx_ecfp_512_public_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Up to 512-bit Elliptic Curve private key"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_512_private_key_s {
    #[doc = "< Curve identifier"]
    pub curve: cx_curve_t,
    #[doc = "< Private key length in bytes"]
    pub d_len: size_t,
    #[doc = "< Private key value starting at offset 0"]
    pub d: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_512_private_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_512_private_key_s>(),
        72usize,
        concat!("Size of: ", stringify!(cx_ecfp_512_private_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_512_private_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_512_private_key_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cx_ecfp_512_private_key_s>())).curve as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_512_private_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cx_ecfp_512_private_key_s>())).d_len as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_512_private_key_s),
            "::",
            stringify!(d_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ecfp_512_private_key_s>())).d as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_512_private_key_s),
            "::",
            stringify!(d)
        )
    );
}
impl Default for cx_ecfp_512_private_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Up to 512-bit Elliptic Curve extended private key"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_512_extented_private_key_s {
    #[doc = "< Curve identifier"]
    pub curve: cx_curve_t,
    #[doc = "< Private key length in bytes"]
    pub d_len: size_t,
    #[doc = "< Private key value starting at offset 0"]
    pub d: [u8; 128usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_512_extented_private_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_512_extented_private_key_s>(),
        136usize,
        concat!("Size of: ", stringify!(cx_ecfp_512_extented_private_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_512_extented_private_key_s>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cx_ecfp_512_extented_private_key_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cx_ecfp_512_extented_private_key_s>())).curve as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_512_extented_private_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cx_ecfp_512_extented_private_key_s>())).d_len as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_512_extented_private_key_s),
            "::",
            stringify!(d_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cx_ecfp_512_extented_private_key_s>())).d as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_512_extented_private_key_s),
            "::",
            stringify!(d)
        )
    );
}
impl Default for cx_ecfp_512_extented_private_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Up to 512-bit Elliptic Curve public key"]
pub type cx_ecfp_512_public_key_t = cx_ecfp_512_public_key_s;
#[doc = " Up to 512-bit Elliptic Curve private key"]
pub type cx_ecfp_512_private_key_t = cx_ecfp_512_private_key_s;
#[doc = " Up to 512-bit Elliptic Curve extended private key"]
pub type cx_ecfp_512_extented_private_key_t = cx_ecfp_512_extented_private_key_s;
#[doc = " Up to 640-bit Elliptic Curve public key"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_640_public_key_s {
    #[doc = "< Curve identifier"]
    pub curve: cx_curve_t,
    #[doc = "< Public key length in bytes"]
    pub W_len: size_t,
    #[doc = "< Public key value starting at offset 0"]
    pub W: [u8; 161usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_640_public_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_640_public_key_s>(),
        172usize,
        concat!("Size of: ", stringify!(cx_ecfp_640_public_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_640_public_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_640_public_key_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ecfp_640_public_key_s>())).curve as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_640_public_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ecfp_640_public_key_s>())).W_len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_640_public_key_s),
            "::",
            stringify!(W_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ecfp_640_public_key_s>())).W as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_640_public_key_s),
            "::",
            stringify!(W)
        )
    );
}
impl Default for cx_ecfp_640_public_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Up to 640-bit Elliptic Curve private key"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_640_private_key_s {
    #[doc = "< Curve identifier"]
    pub curve: cx_curve_t,
    #[doc = "< Private key length in bytes"]
    pub d_len: size_t,
    #[doc = "< Private key value starting at offset 0"]
    pub d: [u8; 80usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_640_private_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_640_private_key_s>(),
        88usize,
        concat!("Size of: ", stringify!(cx_ecfp_640_private_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_640_private_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_640_private_key_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cx_ecfp_640_private_key_s>())).curve as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_640_private_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cx_ecfp_640_private_key_s>())).d_len as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_640_private_key_s),
            "::",
            stringify!(d_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ecfp_640_private_key_s>())).d as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_640_private_key_s),
            "::",
            stringify!(d)
        )
    );
}
impl Default for cx_ecfp_640_private_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Up to 640-bit Elliptic Curve public key"]
pub type cx_ecfp_640_public_key_t = cx_ecfp_640_public_key_s;
#[doc = " Up to 640-bit Elliptic Curve private key"]
pub type cx_ecfp_640_private_key_t = cx_ecfp_640_private_key_s;
extern "C" {
    #[doc = " @brief   Add two points of an elliptic curve."]
    #[doc = ""]
    #[doc = " @param[in]  curve Curve identifier."]
    #[doc = ""]
    #[doc = " @param[out] R     Resulting point encoded as **04 || x || y**."]
    #[doc = ""]
    #[doc = " @param[in]  P     First operand: point on curve encoded as **04 || x || y**:"]
    #[doc = "                   *x* and *y* are encoded as big endian raw values"]
    #[doc = "                   and have a binary length equal to curve domain size."]
    #[doc = ""]
    #[doc = " @param[in]  Q     Second operand: point on curve encoded as **04 || x || y**."]
    #[doc = ""]
    #[doc = " @return           Error code:"]
    #[doc = "                   - CX_OK on success"]
    #[doc = "                   - CX_EC_INVALID_CURVE"]
    #[doc = "                   - CX_NOT_UNLOCKED"]
    #[doc = "                   - CX_INVALID_PARAMETER_SIZE"]
    #[doc = "                   - CX_EC_INVALID_CURVE"]
    #[doc = "                   - CX_MEMORY_FULL"]
    #[doc = "                   - CX_NOT_LOCKED"]
    #[doc = "                   - CX_INVALID_PARAMETER"]
    #[doc = "                   - CX_EC_INVALID_POINT"]
    #[doc = "                   - CX_EC_INFINITE_POINT"]
    pub fn cx_ecfp_add_point_no_throw(
        curve: cx_curve_t,
        R: *mut u8,
        P: *const u8,
        Q: *const u8,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform a scalar multiplication over an elliptic curve."]
    #[doc = ""]
    #[doc = " @param[in]      curve Curve identifier."]
    #[doc = ""]
    #[doc = " @param[in, out] P     Point on curve encoded as **04 || x || y**:"]
    #[doc = "                       x and y are encoded as big endian raw values"]
    #[doc = "                       and have a binary length equal to curve domain size."]
    #[doc = "                       This is also used for the result."]
    #[doc = ""]
    #[doc = " @param[in]      k     Scalar encoded as big endian integer."]
    #[doc = ""]
    #[doc = " @param[in]      k_len Length of the scalar. This should be equal to"]
    #[doc = "                       the curve domain length."]
    #[doc = ""]
    #[doc = " @return               Error code:"]
    #[doc = "                       - CX_OK on success"]
    #[doc = "                       - CX_EC_INVALID_CURVE"]
    #[doc = "                       - CX_NOT_UNLOCKED"]
    #[doc = "                       - CX_EC_INVALID_CURVE"]
    #[doc = "                       - CX_MEMORY_FULL"]
    #[doc = "                       - CX_NOT_LOCKED"]
    #[doc = "                       - CX_INVALID_PARAMETER"]
    #[doc = "                       - CX_EC_INFINITE_POINT"]
    pub fn cx_ecfp_scalar_mult_no_throw(
        curve: cx_curve_t,
        P: *mut u8,
        k: *const u8,
        k_len: size_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Initialize a public key."]
    #[doc = ""]
    #[doc = " @param[in]  curve   Curve identifier."]
    #[doc = ""]
    #[doc = " @param[in]  rawkey  Pointer to a raw key value or NULL pointer"]
    #[doc = "                     The value shall be the public point encoded as:"]
    #[doc = "                      - **04 || x || y** for Weiertrass curves"]
    #[doc = "                      - **04 || x || y**  or **02 || y** (plus sign) for Twisted Edward curves"]
    #[doc = "                      - **04 || x || y**  or **02 || x** for Montgomery curves"]
    #[doc = ""]
    #[doc = "                     where *x* and *y* are encoded as big endian raw values and have a"]
    #[doc = "                     binary length equal to the curve domain size."]
    #[doc = ""]
    #[doc = " @param[in]  key_len Length of the key."]
    #[doc = ""]
    #[doc = " @param[out] key     Public key to initialize."]
    #[doc = ""]
    #[doc = " @return             Error code:"]
    #[doc = "                     - CX_OK on success"]
    #[doc = "                     - CX_EC_INVALID_CURVE"]
    #[doc = "                     - INVALID_PARAMETER"]
    pub fn cx_ecfp_init_public_key_no_throw(
        curve: cx_curve_t,
        rawkey: *const u8,
        key_len: size_t,
        key: *mut cx_ecfp_public_key_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Initialize a private key."]
    #[doc = ""]
    #[doc = " @details The key can be stored in non-volatile memory and"]
    #[doc = "          used for ECDSA or ECDH processing."]
    #[doc = ""]
    #[doc = " @param[in]  curve   Curve identifier."]
    #[doc = ""]
    #[doc = " @param[in]  rawkey  Pointer to a raw key value or NULL pointer."]
    #[doc = "                     The value shall be in big endian order."]
    #[doc = ""]
    #[doc = " @param[in]  key_len Length of the key."]
    #[doc = ""]
    #[doc = " @param[out] pvkey   Private key to initialize."]
    #[doc = ""]
    #[doc = " @return             Error code:"]
    #[doc = "                     - CX_OK on success"]
    #[doc = "                     - CX_EC_INVALID_CURVE"]
    #[doc = "                     - CX_INVALID_PARAMETER"]
    pub fn cx_ecfp_init_private_key_no_throw(
        curve: cx_curve_t,
        rawkey: *const u8,
        key_len: size_t,
        pvkey: *mut cx_ecfp_private_key_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Generate a key pair with SHA-512 hash function."]
    #[doc = ""]
    #[doc = " @param[in]  curve       Curve identifier."]
    #[doc = ""]
    #[doc = " @param[out] pubkey      Generated public key."]
    #[doc = ""]
    #[doc = " @param[out] privkey     Generated private key."]
    #[doc = ""]
    #[doc = " @param[in]  keepprivate If set, the private key is the one initialized"]
    #[doc = "                         with #cx_ecfp_init_private_key_no_throw. Otherwise,"]
    #[doc = "                         a new private key is generated."]
    #[doc = ""]
    #[doc = " @return                 Error code:"]
    #[doc = "                         - CX_OK on success"]
    #[doc = "                         - CX_EC_INVALID_CURVE"]
    #[doc = "                         - CX_NOT_UNLOCKED"]
    #[doc = "                         - CX_INVALID_PARAMETER_SIZE"]
    #[doc = "                         - CX_MEMORY_FULL"]
    #[doc = "                         - CX_NOT_LOCKED"]
    #[doc = "                         - CX_INVALID_PARAMETER"]
    #[doc = "                         - CX_INTERNAL_ERROR"]
    #[doc = "                         - CX_EC_INVALID_POINT"]
    #[doc = "                         - CX_EC_INFINITE_POINT"]
    pub fn cx_ecfp_generate_pair_no_throw(
        curve: cx_curve_t,
        pubkey: *mut cx_ecfp_public_key_t,
        privkey: *mut cx_ecfp_private_key_t,
        keepprivate: bool,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Generate a key pair."]
    #[doc = ""]
    #[doc = " @param[in]  curve       Curve identifier."]
    #[doc = ""]
    #[doc = " @param[out] pubkey      Generated public key."]
    #[doc = ""]
    #[doc = " @param[out] privkey     Generated private key."]
    #[doc = ""]
    #[doc = " @param[in]  keepprivate If set, the private key is the one initialized with"]
    #[doc = "                         #cx_ecfp_init_private_key_no_throw."]
    #[doc = "                         Otherwise, a new private key is generated."]
    #[doc = ""]
    #[doc = " @param[in]  hashID      Message digest algorithm identifer."]
    #[doc = ""]
    #[doc = " @return                 Error code:"]
    #[doc = "                         - CX_OK on success"]
    #[doc = "                         - CX_EC_INVALID_CURVE"]
    #[doc = "                         - CX_NOT_UNLOCKED"]
    #[doc = "                         - CX_INVALID_PARAMETER_SIZE"]
    #[doc = "                         - CX_MEMORY_FULL"]
    #[doc = "                         - CX_NOT_LOCKED"]
    #[doc = "                         - CX_INVALID_PARAMETER"]
    #[doc = "                         - CX_INTERNAL_ERROR"]
    #[doc = "                         - CX_EC_INVALID_POINT"]
    #[doc = "                         - CX_EC_INFINITE_POINT"]
    pub fn cx_ecfp_generate_pair2_no_throw(
        curve: cx_curve_t,
        pubkey: *mut cx_ecfp_public_key_t,
        privkey: *mut cx_ecfp_private_key_t,
        keepprivate: bool,
        hashID: cx_md_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Retrieve an EDDSA public key."]
    #[doc = ""]
    #[doc = " @details Retrieve (a,h) = (Kr, Kl), such that (Kr, Kl) = Hash(pv_key)"]
    #[doc = "          as specified in <a href=\"https://tools.ietf.org/html/rfc8032\"> RFC8032 </a>."]
    #[doc = ""]
    #[doc = " @param[in]  pvkey  A private key fully initialized with #cx_ecfp_init_private_key_no_throw."]
    #[doc = ""]
    #[doc = " @param[in]  hashID Message digest algorithm identifier used to compute the input data."]
    #[doc = "                    SHA512, SHA3 and Keccak are supported."]
    #[doc = ""]
    #[doc = " @param[out] pukey  Key container for retrieving the public key A."]
    #[doc = ""]
    #[doc = " @param[out] a      Private scalar such that A = a.B."]
    #[doc = ""]
    #[doc = " @param[in]  a_len  Length of the scalar a."]
    #[doc = ""]
    #[doc = " @param[out] h      Signature prefix."]
    #[doc = ""]
    #[doc = " @param[in]  h_len  Length of the prefix h."]
    #[doc = ""]
    #[doc = " @return            Error code:"]
    #[doc = "                    - CX_OK on success"]
    #[doc = "                    - CX_EC_INVALID_CURVE"]
    #[doc = "                    - CX_NOT_UNLOCKED"]
    #[doc = "                    - CX_INVALID_PARAMETER_SIZE"]
    #[doc = "                    - CX_INVALID_PARAMETER"]
    #[doc = "                    - CX_NOT_LOCKED"]
    #[doc = "                    - CX_MEMORY_FULL"]
    #[doc = "                    - CX_EC_INVALID_POINT"]
    #[doc = "                    - CX_EC_INFINITE_POINT"]
    #[doc = "                    - CX_INTERNAL_ERROR"]
    #[doc = ""]
    pub fn cx_eddsa_get_public_key_no_throw(
        pvkey: *const cx_ecfp_private_key_t,
        hashID: cx_md_t,
        pukey: *mut cx_ecfp_public_key_t,
        a: *mut u8,
        a_len: size_t,
        h: *mut u8,
        h_len: size_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Compress a point according to <a href=\"https://tools.ietf.org/html/rfc8032\"> RFC8032 </a>."]
    #[doc = ""]
    #[doc = " @param[in]      curve Curve identifier. The curve must be"]
    #[doc = "                       a Twisted Edwards curve."]
    #[doc = ""]
    #[doc = " @param[in, out] p     Pointer to the point to compress."]
    #[doc = ""]
    #[doc = " @param[in]      p_len Length of the point buffer."]
    #[doc = ""]
    #[doc = " @return               Error code:"]
    #[doc = "                       - CX_OK on success"]
    #[doc = "                       - CX_EC_INVALID_CURVE"]
    #[doc = "                       - CX_NOT_UNLOCKED"]
    #[doc = "                       - CX_INVALID_PARAMETER_SIZE"]
    #[doc = "                       - CX_EC_INVALID_CURVE"]
    #[doc = "                       - CX_MEMORY_FULL"]
    #[doc = "                       - CX_NOT_LOCKED"]
    #[doc = "                       - CX_INVALID_PARAMETER"]
    #[doc = "                       - CX_EC_INFINITE_POINT"]
    pub fn cx_edwards_compress_point_no_throw(
        curve: cx_curve_t,
        p: *mut u8,
        p_len: size_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Decompress a point according to <a href=\"https://tools.ietf.org/html/rfc8032\"> RFC8032 </a>."]
    #[doc = ""]
    #[doc = " @param[in]      curve Curve identifier. The curve must be"]
    #[doc = "                       a Twisted Edwards curve."]
    #[doc = ""]
    #[doc = " @param[in, out] p     Pointer to the point to decompress."]
    #[doc = ""]
    #[doc = " @param[in]      p_len Length of the point buffer."]
    #[doc = ""]
    #[doc = " @return               Error code:"]
    #[doc = "                       - CX_OK on success"]
    #[doc = "                       - CX_EC_INVALID_CURVE"]
    #[doc = "                       - CX_NOT_UNLOCKED"]
    #[doc = "                       - CX_INVALID_PARAMETER_SIZE"]
    #[doc = "                       - CX_EC_INVALID_CURVE"]
    #[doc = "                       - CX_MEMORY_FULL"]
    #[doc = "                       - CX_NOT_LOCKED"]
    #[doc = "                       - CX_INVALID_PARAMETER"]
    #[doc = "                       - CX_EC_INFINITE_POINT"]
    #[doc = "                       - CX_NO_RESIDUE"]
    #[doc = "                       - INVALID_PARAMETER"]
    pub fn cx_edwards_decompress_point_no_throw(
        curve: cx_curve_t,
        p: *mut u8,
        p_len: size_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " Set the persisted seed if none yet, else override the volatile seed (in RAM)"]
    pub fn os_perso_set_seed(
        identity: cty::c_uint,
        algorithm: cty::c_uint,
        seed: *mut cty::c_uchar,
        length: cty::c_uint,
    );
}
extern "C" {
    pub fn os_perso_derive_and_set_seed(
        identity: cty::c_uchar,
        prefix: *const cty::c_char,
        prefix_length: cty::c_uint,
        passphrase: *const cty::c_char,
        passphrase_length: cty::c_uint,
        words: *const cty::c_char,
        words_length: cty::c_uint,
    );
}
extern "C" {
    pub fn os_perso_set_words(words: *const cty::c_uchar, length: cty::c_uint);
}
extern "C" {
    pub fn os_perso_finalize();
}
extern "C" {
    pub fn os_perso_isonboarded() -> bolos_bool_t;
}
extern "C" {
    pub fn os_perso_set_onboarding_status(
        pin_set: cty::c_uint,
        kind: cty::c_uint,
        count: cty::c_uint,
        total: cty::c_uint,
        isConfirming: cty::c_uint,
    );
}
extern "C" {
    pub fn os_perso_derive_node_bip32(
        curve: cx_curve_t,
        path: *const cty::c_uint,
        pathLength: cty::c_uint,
        privateKey: *mut cty::c_uchar,
        chain: *mut cty::c_uchar,
    );
}
extern "C" {
    pub fn os_perso_derive_node_with_seed_key(
        mode: cty::c_uint,
        curve: cx_curve_t,
        path: *const cty::c_uint,
        pathLength: cty::c_uint,
        privateKey: *mut cty::c_uchar,
        chain: *mut cty::c_uchar,
        seed_key: *mut cty::c_uchar,
        seed_key_length: cty::c_uint,
    );
}
extern "C" {
    pub fn os_perso_derive_eip2333(
        curve: cx_curve_t,
        path: *const cty::c_uint,
        pathLength: cty::c_uint,
        privateKey: *mut cty::c_uchar,
    );
}
pub const os_setting_e_OS_SETTING_BRIGHTNESS: os_setting_e = 0;
pub const os_setting_e_OS_SETTING_INVERT: os_setting_e = 1;
pub const os_setting_e_OS_SETTING_ROTATION: os_setting_e = 2;
pub const os_setting_e_OS_SETTING_AUTO_LOCK_DELAY: os_setting_e = 3;
pub const os_setting_e_OS_SETTING_SCREEN_LOCK_DELAY: os_setting_e = 4;
pub const os_setting_e_OS_SETTING_POWER_OFF_DELAY: os_setting_e = 5;
pub const os_setting_e_OS_SETTING_PLANEMODE: os_setting_e = 6;
pub const os_setting_e_OS_SETTING_PRIVACY_MODE: os_setting_e = 7;
pub const os_setting_e_OS_SETTING_LAST_INT: os_setting_e = 8;
pub const os_setting_e_OS_SETTING_SAVER_STRING: os_setting_e = 8;
pub const os_setting_e_OS_SETTING_DEVICENAME: os_setting_e = 9;
pub const os_setting_e_OS_SETTING_BLEMACADR: os_setting_e = 10;
pub const os_setting_e_OS_SETTING_LAST: os_setting_e = 11;
pub type os_setting_e = cty::c_uint;
pub use self::os_setting_e as os_setting_t;
extern "C" {
    #[doc = " Retrieve the value of a setting in a user specified buffer, with a max"]
    #[doc = " length, and return the effective returned length."]
    pub fn os_setting_get(
        setting_id: cty::c_uint,
        value: *mut cty::c_uchar,
        maxlen: cty::c_uint,
    ) -> cty::c_uint;
}
extern "C" {
    #[doc = " Define a setting's value from a user buffer and its length. In case of error,"]
    #[doc = " a throw is executed."]
    pub fn os_setting_set(setting_id: cty::c_uint, value: *mut cty::c_uchar, length: cty::c_uint);
}
extern "C" {
    pub fn app_main();
}
extern "C" {
    pub fn os_boot();
}
extern "C" {
    #[doc = " Function takes 0 for first call. Returns 0 when timeout has occured. Returned"]
    #[doc = " value is passed as argument for next call, acting as a timeout context."]
    pub fn io_timeout(last_timeout: cty::c_ushort) -> cty::c_ushort;
}
#[doc = " @brief   AES key container."]
#[doc = ""]
#[doc = " @details Such container should be initialized with cx_ees_init_key to ensure"]
#[doc = " future API compatibility. Indeed, in next API level, the key store format may"]
#[doc = " changed at all. Only 16-byte key (AES128) is supported ."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cx_aes_key_s {
    #[doc = "< key size"]
    pub size: size_t,
    #[doc = "< key value"]
    pub keys: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_cx_aes_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_aes_key_s>(),
        36usize,
        concat!("Size of: ", stringify!(cx_aes_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_aes_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_aes_key_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_aes_key_s>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_aes_key_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_aes_key_s>())).keys as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_aes_key_s),
            "::",
            stringify!(keys)
        )
    );
}
#[doc = " @brief   AES key container."]
#[doc = ""]
#[doc = " @details Such container should be initialized with cx_ees_init_key to ensure"]
#[doc = " future API compatibility. Indeed, in next API level, the key store format may"]
#[doc = " changed at all. Only 16-byte key (AES128) is supported ."]
pub type cx_aes_key_t = cx_aes_key_s;
extern "C" {
    #[doc = " @brief   Set an AES key in hardware."]
    #[doc = ""]
    #[doc = " @param[in] key AES key."]
    #[doc = ""]
    #[doc = " @param[in] mode Operation for which the key will be used."]
    #[doc = ""]
    #[doc = " @return         Error code:"]
    #[doc = "                 - CX_OK on success"]
    #[doc = "                 - CX_INVALID_PARAMETER"]
    pub fn cx_aes_set_key_hw(key: *const cx_aes_key_t, mode: u32) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Reset AES context."]
    pub fn cx_aes_reset_hw();
}
extern "C" {
    #[doc = " @brief   Encrypt or decrypt a block with AES."]
    #[doc = ""]
    #[doc = " @param[in]  inblock  Pointer to the block."]
    #[doc = ""]
    #[doc = " @param[out] outblock Buffer for the output."]
    #[doc = ""]
    #[doc = " @return              Error code:"]
    #[doc = "                      - CX_OK on success"]
    #[doc = "                      - INVALID_PARAMETER"]
    pub fn cx_aes_block_hw(inblock: *const cty::c_uchar, outblock: *mut cty::c_uchar) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief Calculate a 32-bit cyclic redundancy check."]
    #[doc = ""]
    #[doc = " @param[in] buf Pointer to the buffer to check."]
    #[doc = ""]
    #[doc = " @param[in] len Length of the buffer."]
    #[doc = ""]
    #[doc = " @return        Result of the 32-bit CRC calculation."]
    #[doc = ""]
    pub fn cx_crc32_hw(buf: *const cty::c_void, len: size_t) -> u32;
}
#[doc = " @brief   DES key container."]
#[doc = ""]
#[doc = "  @details DES key container."]
#[doc = "           Such container should be initialized with **cx_des_init_key** to"]
#[doc = " ensure future API compatibility. Indeed, in next API level, the key store"]
#[doc = " format may changed at all. 8 bytes (simple DES), 16 bytes (triple DES with 2"]
#[doc = " keys) and 24 bytes (triple DES with 3 keys) are supported."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cx_des_key_s {
    #[doc = "< key size"]
    pub size: u8,
    #[doc = "< key value"]
    pub keys: [u8; 24usize],
}
#[test]
fn bindgen_test_layout_cx_des_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_des_key_s>(),
        25usize,
        concat!("Size of: ", stringify!(cx_des_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_des_key_s>(),
        1usize,
        concat!("Alignment of ", stringify!(cx_des_key_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_des_key_s>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_des_key_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_des_key_s>())).keys as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_des_key_s),
            "::",
            stringify!(keys)
        )
    );
}
#[doc = " @brief   DES key container."]
#[doc = ""]
#[doc = "  @details DES key container."]
#[doc = "           Such container should be initialized with **cx_des_init_key** to"]
#[doc = " ensure future API compatibility. Indeed, in next API level, the key store"]
#[doc = " format may changed at all. 8 bytes (simple DES), 16 bytes (triple DES with 2"]
#[doc = " keys) and 24 bytes (triple DES with 3 keys) are supported."]
pub type cx_des_key_t = cx_des_key_s;
extern "C" {
    #[doc = " @brief   Set a DES key in hardware."]
    #[doc = ""]
    #[doc = " @param[in] keys DES key."]
    #[doc = ""]
    #[doc = " @param[in] mode Operation for which the key will be used."]
    #[doc = ""]
    #[doc = " @return         Error code:"]
    #[doc = "                 - CX_OK on success"]
    #[doc = "                 - INVALID_PARAMETER"]
    pub fn cx_des_set_key_hw(keys: *const cx_des_key_t, mode: u32) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Reset DES context."]
    pub fn cx_des_reset_hw();
}
extern "C" {
    #[doc = " @brief   Encrypt or decrypt a block with DES."]
    #[doc = ""]
    #[doc = " @param[in]  inblock  Pointer to the block."]
    #[doc = ""]
    #[doc = " @param[out] outblock Buffer for the output."]
    pub fn cx_des_block_hw(inblock: *const cty::c_uchar, outblock: *mut cty::c_uchar);
}
extern "C" {
    #[doc = " @brief   Get random data from the True Random Number Generation."]
    #[doc = ""]
    #[doc = " @param[out] buf  Buffer where to store the random data."]
    #[doc = ""]
    #[doc = " @param[in]  size Size of the random data in bytes."]
    #[doc = ""]
    pub fn cx_trng_get_random_data(buf: *mut u8, size: size_t);
}
extern "C" {
    pub fn cx_trng_selftest();
}
extern "C" {
    pub fn cx_trng_init();
}
#[doc = " @brief SHA-224 and SHA-256 context"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_sha256_s {
    #[doc = "< @copydoc cx_ripemd160_s::header"]
    pub header: cx_hash_header_s,
    #[doc = "< @copydoc cx_ripemd160_s::blen"]
    pub blen: size_t,
    #[doc = "< @copydoc cx_ripemd160_s::block"]
    pub block: [u8; 64usize],
    #[doc = "< @copydoc cx_ripemd160_s::acc"]
    pub acc: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_cx_sha256_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_sha256_s>(),
        108usize,
        concat!("Size of: ", stringify!(cx_sha256_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_sha256_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_sha256_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_sha256_s>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha256_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_sha256_s>())).blen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha256_s),
            "::",
            stringify!(blen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_sha256_s>())).block as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha256_s),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_sha256_s>())).acc as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha256_s),
            "::",
            stringify!(acc)
        )
    );
}
impl Default for cx_sha256_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief SHA-224 and SHA-256 context"]
pub type cx_sha256_t = cx_sha256_s;
extern "C" {
    #[doc = " @brief   Initialize a SHA-256 context."]
    #[doc = ""]
    #[doc = " @param[out] hash Pointer to the context."]
    #[doc = "                  The context shall be in RAM."]
    #[doc = ""]
    #[doc = " @return          Error code:"]
    #[doc = "                  - CX_OK on success"]
    pub fn cx_sha256_init_no_throw(hash: *mut cx_sha256_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Compute a one shot SHA-256 digest."]
    #[doc = ""]
    #[doc = " @param[in]  in      Input data."]
    #[doc = ""]
    #[doc = " @param[in]  len     Length of the input data."]
    #[doc = ""]
    #[doc = " @param[out] out     Buffer where to store the digest."]
    #[doc = ""]
    #[doc = " @param[in]  out_len Length of the output."]
    #[doc = "                     This is actually 256 bits."]
    #[doc = ""]
    pub fn cx_hash_sha256(in_: *const u8, len: size_t, out: *mut u8, out_len: size_t) -> size_t;
}
#[doc = " @brief SHA-384 and SHA-512 context"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_sha512_s {
    #[doc = "< @copydoc cx_ripemd160_s::header"]
    pub header: cx_hash_header_s,
    #[doc = "< @copydoc cx_ripemd160_s::blen"]
    pub blen: size_t,
    #[doc = "< @copydoc cx_ripemd160_s::block"]
    pub block: [u8; 128usize],
    #[doc = "< @copydoc cx_ripemd160_s::acc"]
    pub acc: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_cx_sha512_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_sha512_s>(),
        204usize,
        concat!("Size of: ", stringify!(cx_sha512_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_sha512_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_sha512_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_sha512_s>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha512_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_sha512_s>())).blen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha512_s),
            "::",
            stringify!(blen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_sha512_s>())).block as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha512_s),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_sha512_s>())).acc as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha512_s),
            "::",
            stringify!(acc)
        )
    );
}
impl Default for cx_sha512_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief SHA-384 and SHA-512 context"]
pub type cx_sha512_t = cx_sha512_s;
extern "C" {
    #[doc = " @brief   Initialize a SHA-384 context."]
    #[doc = ""]
    #[doc = " @param[out] hash Pointer to the context."]
    #[doc = "                  The context shall be in RAM."]
    #[doc = ""]
    #[doc = " @return          Error code:"]
    #[doc = "                  - CX_OK on success"]
    pub fn cx_sha384_init_no_throw(hash: *mut cx_sha512_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Initialize a SHA-512 context."]
    #[doc = ""]
    #[doc = " @param[out] hash Pointer to the context."]
    #[doc = "                  The context shall be in RAM."]
    #[doc = ""]
    #[doc = " @return          Error code:"]
    #[doc = "                  - CX_OK on success"]
    pub fn cx_sha512_init_no_throw(hash: *mut cx_sha512_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Compute a one shot SHA-512 digest."]
    #[doc = ""]
    #[doc = " @param[in]  in      Input data."]
    #[doc = ""]
    #[doc = " @param[in]  in_len  Length of the input data."]
    #[doc = ""]
    #[doc = " @param[out] out     Buffer where to store the output."]
    #[doc = ""]
    #[doc = " @param[out] out_len Length of the output."]
    #[doc = "                     This is actually 512 bits."]
    pub fn cx_hash_sha512(in_: *const u8, in_len: size_t, out: *mut u8, out_len: size_t) -> size_t;
}
#[doc = "< Size of a block"]
pub const blake2b_constant_BLAKE2B_BLOCKBYTES: blake2b_constant = 128;
#[doc = "< Size of the output"]
pub const blake2b_constant_BLAKE2B_OUTBYTES: blake2b_constant = 64;
#[doc = "< Size of the key"]
pub const blake2b_constant_BLAKE2B_KEYBYTES: blake2b_constant = 64;
#[doc = "< Size of the salt"]
pub const blake2b_constant_BLAKE2B_SALTBYTES: blake2b_constant = 16;
#[doc = "< Size of the personalization string"]
pub const blake2b_constant_BLAKE2B_PERSONALBYTES: blake2b_constant = 16;
#[doc = "  @private BLAKE2b constants"]
pub type blake2b_constant = cty::c_uint;
#[doc = "  @private BLAKE2b state members"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blake2b_state__ {
    #[doc = "< Internal state of the hash"]
    pub h: [u64; 8usize],
    #[doc = "< Message byte offset at the end of the current block"]
    pub t: [u64; 2usize],
    #[doc = "< Flag indicating the last block"]
    pub f: [u64; 2usize],
    #[doc = "< Buffer for the processed data"]
    pub buf: [u8; 128usize],
    #[doc = "< Length of the buffer"]
    pub buflen: size_t,
    #[doc = "< Length of the output"]
    pub outlen: size_t,
    #[doc = "< Last node"]
    pub last_node: u8,
}
#[test]
fn bindgen_test_layout_blake2b_state__() {
    assert_eq!(
        ::core::mem::size_of::<blake2b_state__>(),
        240usize,
        concat!("Size of: ", stringify!(blake2b_state__))
    );
    assert_eq!(
        ::core::mem::align_of::<blake2b_state__>(),
        8usize,
        concat!("Alignment of ", stringify!(blake2b_state__))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blake2b_state__>())).h as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state__),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blake2b_state__>())).t as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state__),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blake2b_state__>())).f as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state__),
            "::",
            stringify!(f)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blake2b_state__>())).buf as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state__),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blake2b_state__>())).buflen as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state__),
            "::",
            stringify!(buflen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blake2b_state__>())).outlen as *const _ as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state__),
            "::",
            stringify!(outlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blake2b_state__>())).last_node as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state__),
            "::",
            stringify!(last_node)
        )
    );
}
impl Default for blake2b_state__ {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "  @private BLAKE2b state members"]
pub type blake2b_state = blake2b_state__;
#[doc = " @brief BLAKE2b context"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_blake2b_s {
    #[doc = "< @copydoc cx_ripemd160_s::header"]
    pub header: cx_hash_header_s,
    #[doc = "< Output digest size"]
    pub output_size: size_t,
    #[doc = "< BLAKE2B state"]
    pub ctx: blake2b_state__,
}
#[test]
fn bindgen_test_layout_cx_blake2b_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_blake2b_s>(),
        256usize,
        concat!("Size of: ", stringify!(cx_blake2b_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_blake2b_s>(),
        8usize,
        concat!("Alignment of ", stringify!(cx_blake2b_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_blake2b_s>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_blake2b_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_blake2b_s>())).output_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_blake2b_s),
            "::",
            stringify!(output_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_blake2b_s>())).ctx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_blake2b_s),
            "::",
            stringify!(ctx)
        )
    );
}
impl Default for cx_blake2b_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief BLAKE2b context"]
pub type cx_blake2b_t = cx_blake2b_s;
extern "C" {
    #[doc = " @brief   Initialize BLAKE2b message digest context."]
    #[doc = ""]
    #[doc = " @param[out] hash    Pointer to the BLAKE2b context to initialize."]
    #[doc = "                     The context shall be in RAM."]
    #[doc = ""]
    #[doc = " @param[in]  out_len Digest size in bits."]
    #[doc = ""]
    #[doc = " @return             Error code:"]
    #[doc = "                     - CX_OK"]
    #[doc = "                     - CX_INVALID_PARAMETER"]
    pub fn cx_blake2b_init_no_throw(hash: *mut cx_blake2b_t, out_len: size_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Initialize BLAKE2b message digest context with"]
    #[doc = "          salt and personnalization string."]
    #[doc = ""]
    #[doc = " @param[out] hash     Pointer to the BLAKE2b context to initialize."]
    #[doc = "                      The context shall be in RAM."]
    #[doc = ""]
    #[doc = " @param[in] out_len   Digest size in bits."]
    #[doc = ""]
    #[doc = " @param[in] salt      Pointer to a salt (optional)."]
    #[doc = ""]
    #[doc = " @param[in] salt_len  Length of the salt."]
    #[doc = ""]
    #[doc = " @param[in] perso     Pointer to a personalization string (optional)."]
    #[doc = ""]
    #[doc = " @param[in] perso_len Length of the personalization string."]
    #[doc = ""]
    #[doc = " @return              Error code:"]
    #[doc = "                      - CX_OK on success"]
    #[doc = "                      - CX_INVALID_PARAMETER"]
    pub fn cx_blake2b_init2_no_throw(
        hash: *mut cx_blake2b_t,
        out_len: size_t,
        salt: *mut u8,
        salt_len: size_t,
        perso: *mut u8,
        perso_len: size_t,
    ) -> cx_err_t;
}
#[doc = " @brief HMAC context, abstract type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_hmac_t {
    #[doc = "< Key"]
    pub key: [u8; 128usize],
    #[doc = "< Hash context"]
    pub hash_ctx: cx_hash_t,
}
#[test]
fn bindgen_test_layout_cx_hmac_t() {
    assert_eq!(
        ::core::mem::size_of::<cx_hmac_t>(),
        136usize,
        concat!("Size of: ", stringify!(cx_hmac_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_hmac_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_hmac_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_hmac_t>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hmac_t),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_hmac_t>())).hash_ctx as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hmac_t),
            "::",
            stringify!(hash_ctx)
        )
    );
}
impl Default for cx_hmac_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief HMAC context, concrete type for SHA-224/SHA-256"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_hmac_sha256_t {
    #[doc = "< Key"]
    pub key: [u8; 128usize],
    #[doc = "< Hash context"]
    pub hash_ctx: cx_sha256_t,
}
#[test]
fn bindgen_test_layout_cx_hmac_sha256_t() {
    assert_eq!(
        ::core::mem::size_of::<cx_hmac_sha256_t>(),
        236usize,
        concat!("Size of: ", stringify!(cx_hmac_sha256_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_hmac_sha256_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_hmac_sha256_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_hmac_sha256_t>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hmac_sha256_t),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_hmac_sha256_t>())).hash_ctx as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hmac_sha256_t),
            "::",
            stringify!(hash_ctx)
        )
    );
}
impl Default for cx_hmac_sha256_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief   Initialize a HMAC-SHA256 context."]
    #[doc = ""]
    #[doc = " @param[out] hmac    Pointer to the HMAC context."]
    #[doc = "                     The context shall be in RAM."]
    #[doc = ""]
    #[doc = " @param[in]  key     Pointer to the HMAC key value."]
    #[doc = "                     If a key has been set, passing"]
    #[doc = "                     NULL pointeur will reinitialize"]
    #[doc = "                     the context with the previously set key."]
    #[doc = ""]
    #[doc = " @param [in] key_len Length of the key."]
    #[doc = "                     The key length shall be less than 64 bytes."]
    #[doc = ""]
    #[doc = " @return             Error code:"]
    #[doc = "                     - CX_OK on success"]
    #[doc = "                     - CX_INVALID_PARAMETER"]
    pub fn cx_hmac_sha256_init_no_throw(
        hmac: *mut cx_hmac_sha256_t,
        key: *const u8,
        key_len: size_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Compute a HMAC value using SHA256."]
    #[doc = ""]
    #[doc = " @param[in]  key     HMAC key value."]
    #[doc = ""]
    #[doc = " @param[in]  key_len Length of the HMAC key."]
    #[doc = ""]
    #[doc = " @param[in]  in      Input data."]
    #[doc = ""]
    #[doc = " @param[in]  len     Length of the input data."]
    #[doc = ""]
    #[doc = " @param[out] mac     Computed HMAC value."]
    #[doc = ""]
    #[doc = " @param[in]  mac_len Size of the output buffer."]
    #[doc = "                     The buffer size must be larger"]
    #[doc = "                     than the length of the HMAC value."]
    #[doc = ""]
    #[doc = " @return             Length of the HMAC value."]
    pub fn cx_hmac_sha256(
        key: *const u8,
        key_len: size_t,
        in_: *const u8,
        len: size_t,
        mac: *mut u8,
        mac_len: size_t,
    ) -> size_t;
}
#[doc = " @brief HMAC context, concrete type for SHA-384/SHA-512"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_hmac_sha512_t {
    #[doc = "< Key"]
    pub key: [u8; 128usize],
    #[doc = "< Hash context"]
    pub hash_ctx: cx_sha512_t,
}
#[test]
fn bindgen_test_layout_cx_hmac_sha512_t() {
    assert_eq!(
        ::core::mem::size_of::<cx_hmac_sha512_t>(),
        332usize,
        concat!("Size of: ", stringify!(cx_hmac_sha512_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_hmac_sha512_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_hmac_sha512_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_hmac_sha512_t>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hmac_sha512_t),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_hmac_sha512_t>())).hash_ctx as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hmac_sha512_t),
            "::",
            stringify!(hash_ctx)
        )
    );
}
impl Default for cx_hmac_sha512_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief   Initialize a HMAC-SHA512 context."]
    #[doc = ""]
    #[doc = " @param[out] hmac    Pointer to the context."]
    #[doc = "                     The context shall be in RAM."]
    #[doc = ""]
    #[doc = " @param[in]  key     Pointer to the HMAC key value."]
    #[doc = "                     If a key has been set, passing"]
    #[doc = "                     NULL pointeur will reinitialize"]
    #[doc = "                     the context with the previously set key."]
    #[doc = ""]
    #[doc = " @param[in]  key_len Length of the key."]
    #[doc = "                     The key length shall be less than 128 bytes."]
    #[doc = ""]
    #[doc = " @return             Error code:"]
    #[doc = "                     - CX_OK on success"]
    #[doc = "                     - CX_INVALID_PARAMETER"]
    pub fn cx_hmac_sha512_init_no_throw(
        hmac: *mut cx_hmac_sha512_t,
        key: *const u8,
        key_len: size_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Compute a HMAC value using SHA512."]
    #[doc = ""]
    #[doc = " @param[in]  key     HMAC key value."]
    #[doc = ""]
    #[doc = " @param[in]  key_len Length of the HMAC key."]
    #[doc = ""]
    #[doc = " @param[in]  in      Input data."]
    #[doc = ""]
    #[doc = " @param[in]  len     Length of the input data."]
    #[doc = ""]
    #[doc = " @param[out] mac     Computed HMAC value."]
    #[doc = ""]
    #[doc = " @param[in]  mac_len Size of the output buffer."]
    #[doc = "                     The buffer size must be larger"]
    #[doc = "                     than the length of the HMAC value."]
    #[doc = ""]
    #[doc = " @return             Length of the HMAC value."]
    pub fn cx_hmac_sha512(
        key: *const u8,
        key_len: size_t,
        in_: *const u8,
        len: size_t,
        mac: *mut u8,
        mac_len: size_t,
    ) -> size_t;
}
extern "C" {
    #[doc = " @brief   Compute a HMAC value according to the specified"]
    #[doc = "          hash function."]
    #[doc = ""]
    #[doc = " @param[in]  hmac    Pointer to the HMAC context."]
    #[doc = "                     The context shall be initialized with"]
    #[doc = "                     one of the initialization functions."]
    #[doc = "                     The context shall be in RAM."]
    #[doc = "                     The function shall be called with the cast"]
    #[doc = "                     (cx_hmac_t *)."]
    #[doc = ""]
    #[doc = " @param[in]  mode    Crypto mode flags. Supported flags:"]
    #[doc = "                       - CX_LAST"]
    #[doc = "                       - CX_NO_REINIT"]
    #[doc = "                     If CX_LAST is set and CX_NO_REINIT is not set, the context is"]
    #[doc = "                     reinitialized."]
    #[doc = ""]
    #[doc = " @param[in]  in      Input data to add to the context."]
    #[doc = ""]
    #[doc = " @param[in]  len     Length of the input data."]
    #[doc = ""]
    #[doc = " @param[out] mac     Pointer to the computed HMAC or NULL pointer (if CX_LAST is not set)."]
    #[doc = ""]
    #[doc = " @param[in]  mac_len Length of the output buffer if not NULL, 0 otherwise."]
    #[doc = "                     The buffer size must be larger"]
    #[doc = "                     than the length of the HMAC value."]
    #[doc = ""]
    #[doc = " @return             Error code:"]
    #[doc = "                     - CX_OK on success"]
    #[doc = "                     - CX_INVALID_PARAMETER"]
    pub fn cx_hmac_no_throw(
        hmac: *mut cx_hmac_t,
        mode: u32,
        in_: *const u8,
        len: size_t,
        mac: *mut u8,
        mac_len: size_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Initialize a HMAC context."]
    #[doc = ""]
    #[doc = " @param[out] hmac    Pointer to the context."]
    #[doc = "                     The context shall be in RAM."]
    #[doc = ""]
    #[doc = " @param[in]  hash_id The message digest algorithm identifier"]
    #[doc = ""]
    #[doc = " @param[in]  key     Pointer to the HMAC key value."]
    #[doc = "                     If a key has been set, passing"]
    #[doc = "                     NULL pointeur will reinitialize"]
    #[doc = "                     the context with the previously set key."]
    #[doc = ""]
    #[doc = " @param[in]  key_len Length of the key."]
    #[doc = "                     The key length shall be less than 128 bytes."]
    #[doc = ""]
    #[doc = " @return             Error code:"]
    #[doc = "                     - CX_OK on success"]
    #[doc = "                     - CX_INVALID_PARAMETER"]
    pub fn cx_hmac_init(
        hmac: *mut cx_hmac_t,
        hash_id: cx_md_t,
        key: *const u8,
        key_len: size_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Add more data to compute the HMAC."]
    #[doc = ""]
    #[doc = " @details A call to this function is equivalent to:"]
    #[doc = "          *cx_hmac_no_throw(hmac, 0, in, in_len, NULL, 0)*."]
    #[doc = ""]
    #[doc = " @param[out] hmac   Pointer to the HMAC context."]
    #[doc = ""]
    #[doc = " @param[in]  in     Input data to add to the context."]
    #[doc = ""]
    #[doc = " @param[in]  in_len Length of the input data."]
    #[doc = ""]
    #[doc = " @return            Error code:"]
    #[doc = "                    - CX_OK on success"]
    #[doc = "                    - CX_INVALID_PARAMETER"]
    #[doc = "                    - INVALID_PARAMETER"]
    pub fn cx_hmac_update(hmac: *mut cx_hmac_t, in_: *const u8, in_len: size_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Finalize the HMAC algorithm."]
    #[doc = ""]
    #[doc = " @details A call to this function is"]
    #[doc = "          equivalent to *cx_hmac_no_throw(hash, CX_LAST, NULL, 0, out, out_len)*."]
    #[doc = ""]
    #[doc = " @param[in]  ctx     Pointer to the HMAC context."]
    #[doc = " @param[out] out     Computed HMAC value is CX_LAST is set."]
    #[doc = ""]
    #[doc = " @param[in]  out_len Length of the output (the most significant bytes)."]
    #[doc = ""]
    #[doc = " @return             Error code:"]
    #[doc = "                     - CX_OK on success"]
    pub fn cx_hmac_final(ctx: *mut cx_hmac_t, out: *mut u8, out_len: *mut size_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief Compare two integers represented as byte arrays."]
    #[doc = ""]
    #[doc = " @param[in]  a      Pointer to the first integer."]
    #[doc = ""]
    #[doc = " @param[in]  b      Pointer to the second integer."]
    #[doc = ""]
    #[doc = " @param[in]  length Number of bytes taken into account for the comparison."]
    #[doc = ""]
    #[doc = " @param[out] diff   Result of the comparison:"]
    #[doc = "                    - 0 if a and b are identical"]
    #[doc = "                    - < 0 if a is less than b"]
    #[doc = "                    - > 0 if a is greater than b"]
    #[doc = ""]
    #[doc = " @return            Error code:"]
    #[doc = "                    - CX_OK on success"]
    #[doc = "                    - CX_NOT_UNLOCKED"]
    #[doc = "                    - CX_INVALID_PARAMETER_SIZE"]
    #[doc = "                    - CX_NOT_LOCKED"]
    #[doc = "                    - CX_MEMORY_FULL"]
    #[doc = "                    - CX_INVALID_PARAMETER"]
    pub fn cx_math_cmp_no_throw(
        a: *const u8,
        b: *const u8,
        length: size_t,
        diff: *mut cty::c_int,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief Add two integers represented as byte arrays."]
    #[doc = ""]
    #[doc = " @param[out] r   Buffer for the result."]
    #[doc = ""]
    #[doc = " @param[in]  a   Pointer to the first integer."]
    #[doc = ""]
    #[doc = " @param[in]  b   Pointer to the second integer."]
    #[doc = ""]
    #[doc = " @param[in]  len Number of bytes taken into account for the addition."]
    #[doc = ""]
    #[doc = " @return         Error code:"]
    #[doc = "                 - CX_OK on success"]
    #[doc = "                 - CX_NOT_UNLOCKED"]
    #[doc = "                 - CX_INVALID_PARAMETER_SIZE"]
    #[doc = "                 - CX_NOT_LOCKED"]
    #[doc = "                 - CX_MEMORY_FULL"]
    #[doc = "                 - CX_INVALID_PARAMETER"]
    pub fn cx_math_add_no_throw(r: *mut u8, a: *const u8, b: *const u8, len: size_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief Subtract two integers represented as byte arrays."]
    #[doc = ""]
    #[doc = " @param[out] r   Buffer for the result."]
    #[doc = ""]
    #[doc = " @param[in]  a   Pointer to the first integer."]
    #[doc = ""]
    #[doc = " @param[in]  b   Pointer to the second integer."]
    #[doc = ""]
    #[doc = " @param[in]  len Number of bytes taken into account for the subtraction."]
    #[doc = ""]
    #[doc = " @return         Error code:"]
    #[doc = "                 - CX_OK on success"]
    #[doc = "                 - CX_NOT_UNLOCKED"]
    #[doc = "                 - CX_INVALID_PARAMETER_SIZE"]
    #[doc = "                 - CX_NOT_LOCKED"]
    #[doc = "                 - CX_MEMORY_FULL"]
    #[doc = "                 - CX_INVALID_PARAMETER"]
    pub fn cx_math_sub_no_throw(r: *mut u8, a: *const u8, b: *const u8, len: size_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief Multiply two integers represented as byte arrays."]
    #[doc = ""]
    #[doc = " @param[out] r   Buffer for the result."]
    #[doc = ""]
    #[doc = " @param[in]  a   Pointer to the first integer."]
    #[doc = ""]
    #[doc = " @param[in]  b   Pointer to the second integer."]
    #[doc = ""]
    #[doc = " @param[in]  len Number of bytes taken into account for the multiplication."]
    #[doc = ""]
    #[doc = " @return         Error code:"]
    #[doc = "                 - CX_OK on success"]
    #[doc = "                 - CX_NOT_UNLOCKED"]
    #[doc = "                 - CX_INVALID_PARAMETER_SIZE"]
    #[doc = "                 - CX_NOT_LOCKED"]
    #[doc = "                 - CX_MEMORY_FULL"]
    #[doc = "                 - CX_INVALID_PARAMETER"]
    pub fn cx_math_mult_no_throw(r: *mut u8, a: *const u8, b: *const u8, len: size_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief Modular addition of two integers represented as byte arrays."]
    #[doc = ""]
    #[doc = " @param[out] r   Buffer for the result."]
    #[doc = ""]
    #[doc = " @param[in]  a   Pointer to the first integer."]
    #[doc = "                 This must be strictly smaller than the modulus."]
    #[doc = ""]
    #[doc = " @param[in]  b   Pointer to the second integer."]
    #[doc = "                 This must be strictly smaller than the modulus."]
    #[doc = ""]
    #[doc = " @param[in]  m   Modulus"]
    #[doc = ""]
    #[doc = " @param[in]  len Number of bytes taken into account for the operation."]
    #[doc = ""]
    #[doc = " @return         Error code:"]
    #[doc = "                 - CX_OK on success"]
    #[doc = "                 - CX_NOT_UNLOCKED"]
    #[doc = "                 - CX_INVALID_PARAMETER_SIZE"]
    #[doc = "                 - CX_NOT_LOCKED"]
    #[doc = "                 - CX_MEMORY_FULL"]
    #[doc = "                 - CX_INVALID_PARAMETER"]
    pub fn cx_math_addm_no_throw(
        r: *mut u8,
        a: *const u8,
        b: *const u8,
        m: *const u8,
        len: size_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief Modular subtraction of two integers represented as byte arrays."]
    #[doc = ""]
    #[doc = " @param[out] r   Buffer for the result."]
    #[doc = ""]
    #[doc = " @param[in]  a   Pointer to the first integer."]
    #[doc = "                 This must be strictly smaller than the modulus."]
    #[doc = ""]
    #[doc = " @param[in]  b   Pointer to the second integer."]
    #[doc = "                 This must be strictly smaller than the modulus."]
    #[doc = ""]
    #[doc = " @param[in]  m   Modulus"]
    #[doc = ""]
    #[doc = " @param[in]  len Number of bytes taken into account for the operation."]
    #[doc = ""]
    #[doc = " @return         Error code:"]
    #[doc = "                 - CX_OK on success"]
    #[doc = "                 - CX_NOT_UNLOCKED"]
    #[doc = "                 - CX_INVALID_PARAMETER_SIZE"]
    #[doc = "                 - CX_NOT_LOCKED"]
    #[doc = "                 - CX_MEMORY_FULL"]
    #[doc = "                 - CX_INVALID_PARAMETER"]
    pub fn cx_math_subm_no_throw(
        r: *mut u8,
        a: *const u8,
        b: *const u8,
        m: *const u8,
        len: size_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief Modular multiplication of two integers represented as byte arrays."]
    #[doc = ""]
    #[doc = " @param[out] r   Buffer for the result."]
    #[doc = ""]
    #[doc = " @param[in]  a   Pointer to the first integer."]
    #[doc = ""]
    #[doc = " @param[in]  b   Pointer to the second integer."]
    #[doc = "                 This must be strictly smaller than the modulus."]
    #[doc = ""]
    #[doc = " @param[in]  m   Modulus"]
    #[doc = ""]
    #[doc = " @param[in]  len Number of bytes taken into account for the operation."]
    #[doc = ""]
    #[doc = " @return         Error code:"]
    #[doc = "                 - CX_OK on success"]
    #[doc = "                 - CX_NOT_UNLOCKED"]
    #[doc = "                 - CX_INVALID_PARAMETER_SIZE"]
    #[doc = "                 - CX_NOT_LOCKED"]
    #[doc = "                 - CX_MEMORY_FULL"]
    #[doc = "                 - CX_INVALID_PARAMETER"]
    #[doc = "                 - CX_INVALID_PARAMETER_VALUE"]
    pub fn cx_math_multm_no_throw(
        r: *mut u8,
        a: *const u8,
        b: *const u8,
        m: *const u8,
        len: size_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Modulo operation."]
    #[doc = ""]
    #[doc = " @details Compute the remainder of the division of v by m. Store the result in v."]
    #[doc = ""]
    #[doc = " @param[in,out] v     Pointer to the dividend and buffer for the result."]
    #[doc = ""]
    #[doc = " @param[in]     len_v Number of bytes of the dividend."]
    #[doc = ""]
    #[doc = " @param[in]     m     Modulus."]
    #[doc = ""]
    #[doc = " @param[in]     len_m Number of bytes of the modulus."]
    #[doc = ""]
    #[doc = " @return              Error code:"]
    #[doc = "                      - CX_OK on success"]
    #[doc = "                      - CX_NOT_UNLOCKED"]
    #[doc = "                      - CX_INVALID_PARAMETER_SIZE"]
    #[doc = "                      - CX_NOT_LOCKED"]
    #[doc = "                      - CX_MEMORY_FULL"]
    #[doc = "                      - CX_INVALID_PARAMETER"]
    pub fn cx_math_modm_no_throw(
        v: *mut u8,
        len_v: size_t,
        m: *const u8,
        len_m: size_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Modular exponentiation."]
    #[doc = ""]
    #[doc = " @details Compute the result of **a^e mod m**."]
    #[doc = ""]
    #[doc = " @param[out] r     Buffer for the result."]
    #[doc = ""]
    #[doc = " @param[in]  a     Pointer to an integer."]
    #[doc = ""]
    #[doc = " @param[in]  e     Pointer to the exponent."]
    #[doc = ""]
    #[doc = " @param[in]  len_e Number of bytes of the exponent."]
    #[doc = ""]
    #[doc = " @param[in]  m     Modulus"]
    #[doc = ""]
    #[doc = " @param[in]  len   Number of bytes of the result."]
    #[doc = ""]
    #[doc = " @return           Error code:"]
    #[doc = "                   - CX_OK on success"]
    #[doc = "                   - CX_NOT_UNLOCKED"]
    #[doc = "                   - CX_INVALID_PARAMETER_SIZE"]
    #[doc = "                   - CX_NOT_LOCKED"]
    #[doc = "                   - CX_MEMORY_FULL"]
    #[doc = "                   - CX_INVALID_PARAMETER"]
    pub fn cx_math_powm_no_throw(
        r: *mut u8,
        a: *const u8,
        e: *const u8,
        len_e: size_t,
        m: *const u8,
        len: size_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Modular inverse with a prime modulus."]
    #[doc = ""]
    #[doc = " @details Compute the result of **a^(-1) mod m**, for a prime *m*."]
    #[doc = ""]
    #[doc = " @param[out] r   Buffer for the result."]
    #[doc = ""]
    #[doc = " @param[in]  a   Pointer to the integer."]
    #[doc = ""]
    #[doc = " @param[in]  m   Modulus. Must be a prime number."]
    #[doc = ""]
    #[doc = " @param[in]  len Number of bytes of the result."]
    #[doc = ""]
    #[doc = " @return         Error code:"]
    #[doc = "                 - CX_OK on success"]
    #[doc = "                 - CX_NOT_UNLOCKED"]
    #[doc = "                 - CX_INVALID_PARAMETER_SIZE"]
    #[doc = "                 - CX_NOT_LOCKED"]
    #[doc = "                 - CX_MEMORY_FULL"]
    #[doc = "                 - CX_INVALID_PARAMETER"]
    pub fn cx_math_invprimem_no_throw(
        r: *mut u8,
        a: *const u8,
        m: *const u8,
        len: size_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Modular inverse."]
    #[doc = ""]
    #[doc = " @details Compute the result of **a^(-1) mod m**. *a* must be invertible modulo *m*,"]
    #[doc = "          i.e. the greatest common divisor of *a* and *n* is 1."]
    #[doc = ""]
    #[doc = " @param[out] r   Buffer for the result."]
    #[doc = ""]
    #[doc = " @param[in]  a   Pointer to the integer."]
    #[doc = ""]
    #[doc = " @param[in]  m   Modulus."]
    #[doc = ""]
    #[doc = " @param[in]  len Number of bytes of the result."]
    #[doc = ""]
    #[doc = " @return         Error code:"]
    #[doc = "                 - CX_OK on success"]
    #[doc = "                 - CX_NOT_UNLOCKED"]
    #[doc = "                 - CX_INVALID_PARAMETER_SIZE"]
    #[doc = "                 - CX_NOT_LOCKED"]
    #[doc = "                 - CX_MEMORY_FULL"]
    #[doc = "                 - CX_INVALID_PARAMETER"]
    pub fn cx_math_invintm_no_throw(r: *mut u8, a: u32, m: *const u8, len: size_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief Check whether a number is probable prime."]
    #[doc = ""]
    #[doc = " @param[in]  r     Pointer to an integer."]
    #[doc = ""]
    #[doc = " @param[in]  len   Number of bytes of the integer."]
    #[doc = ""]
    #[doc = " @param[out] prime Bool indicating whether r is prime or not:"]
    #[doc = "                   - 0 : not prime"]
    #[doc = "                   - 1 : prime"]
    #[doc = ""]
    #[doc = " @return           Error code:"]
    #[doc = "                   - CX_OK on success"]
    #[doc = "                   - CX_NOT_UNLOCKED"]
    #[doc = "                   - CX_INVALID_PARAMETER_SIZE"]
    #[doc = "                   - CX_NOT_LOCKED"]
    #[doc = "                   - CX_MEMORY_FULL"]
    #[doc = "                   - CX_INVALID_PARAMETER"]
    pub fn cx_math_is_prime_no_throw(r: *const u8, len: size_t, prime: *mut bool) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief Compute the next prime after a given number."]
    #[doc = ""]
    #[doc = " @param[in] r   Pointer to the integer and buffer for the result."]
    #[doc = ""]
    #[doc = " @param[in] len Number of bytes of the integer."]
    #[doc = ""]
    #[doc = " @return        Error code:"]
    #[doc = "                - CX_OK on success"]
    #[doc = "                - CX_NOT_UNLOCKED"]
    #[doc = "                - CX_INVALID_PARAMETER_SIZE"]
    #[doc = "                - CX_MEMORY_FULL"]
    #[doc = "                - CX_NOT_LOCKED"]
    #[doc = "                - CX_INVALID_PARAMETER"]
    #[doc = "                - CX_INTERNAL_ERROR"]
    #[doc = "                - CX_OVERFLOW"]
    pub fn cx_math_next_prime_no_throw(r: *mut u8, len: u32) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Sign a message digest according to ECDSA specification"]
    #[doc = ""]
    #[doc = " @param[in]  pvkey    Private key."]
    #[doc = "                      Shall be initialized with #cx_ecfp_init_private_key_no_throw."]
    #[doc = ""]
    #[doc = " @param[in]  mode     Crypto mode flags."]
    #[doc = "                      Supported flags:"]
    #[doc = "                        - CX_RND_TRNG"]
    #[doc = "                        - CX_RND_RFC6979"]
    #[doc = ""]
    #[doc = " @param[in]  hashID   Message digest algorithm identifer."]
    #[doc = "                      This parameter is mandatory with the flag CX_RND_RFC6979."]
    #[doc = ""]
    #[doc = " @param[in]  hash     Digest of the message to be signed."]
    #[doc = "                      The length of *hash* must be shorter than the curve domain size."]
    #[doc = ""]
    #[doc = " @param[in]  hash_len Length of the digest in octets."]
    #[doc = ""]
    #[doc = " @param[out] sig      Buffer where to store the signature."]
    #[doc = "                      The signature is encoded in TLV:  **30 || L || 02 || Lr || r || 02 || Ls || s**"]
    #[doc = ""]
    #[doc = " @param[in]  sig_len  Length of the buffer in octets."]
    #[doc = ""]
    #[doc = " @param[out] info     Set with CX_ECCINFO_PARITY_ODD if the y-coordinate is odd when computing **[k].G**."]
    #[doc = ""]
    #[doc = " @return              Error code:"]
    #[doc = "                      - CX_OK on success"]
    #[doc = "                      - CX_EC_INVALID_CURVE"]
    #[doc = "                      - CX_INVALID_PARAMETER"]
    #[doc = "                      - CX_INTERNAL_ERROR"]
    #[doc = "                      - CX_NOT_UNLOCKED"]
    #[doc = "                      - CX_INVALID_PARAMETER_SIZE"]
    #[doc = "                      - CX_MEMORY_FULL"]
    #[doc = "                      - CX_NOT_LOCKED"]
    #[doc = "                      - CX_EC_INVALID_POINT"]
    #[doc = "                      - CX_EC_INFINITE_POINT"]
    #[doc = "                      - CX_INVALID_PARAMETER_VALUE"]
    pub fn cx_ecdsa_sign_no_throw(
        pvkey: *const cx_ecfp_private_key_t,
        mode: u32,
        hashID: cx_md_t,
        hash: *const u8,
        hash_len: size_t,
        sig: *mut u8,
        sig_len: *mut size_t,
        info: *mut u32,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Verify an ECDSA signature according to ECDSA specification."]
    #[doc = ""]
    #[doc = " @param[in] pukey    Private key initialized with #cx_ecfp_init_public_key_no_throw."]
    #[doc = ""]
    #[doc = " @param[in] hash     Digest of the message to be verified."]
    #[doc = "                     The length of *hash* must be smaller than the group order size."]
    #[doc = "                     Otherwise it is truncated."]
    #[doc = ""]
    #[doc = " @param[in] hash_len Length of the digest in octets."]
    #[doc = ""]
    #[doc = " @param[in] sig      Pointer to the signature encoded in TLV: **30 || L || 02 || Lr || r || 02 || Ls || s**"]
    #[doc = ""]
    #[doc = " @param[in] sig_len  Length of the signature in octets."]
    #[doc = ""]
    #[doc = " @return             1 if the signature is verified, 0 otherwise."]
    pub fn cx_ecdsa_verify_no_throw(
        pukey: *const cx_ecfp_public_key_t,
        hash: *const u8,
        hash_len: size_t,
        sig: *const u8,
        sig_len: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief   Sign a message digest."]
    #[doc = ""]
    #[doc = " @details Sign a message digest according to the EDDSA specification"]
    #[doc = "          <a href=\"https://tools.ietf.org/html/rfc8032\"> RFC8032 </a>."]
    #[doc = ""]
    #[doc = " @param[in]  pvkey    Private key."]
    #[doc = "                      This shall be initialized with #cx_ecfp_init_private_key_no_throw."]
    #[doc = ""]
    #[doc = " @param[in]  hashID   Message digest agorithm identifier."]
    #[doc = "                      Algorithms supported:"]
    #[doc = "                        - SHA512"]
    #[doc = "                        - SHA3"]
    #[doc = "                        - Keccak"]
    #[doc = ""]
    #[doc = " @param[in]  hash     Pointer to the message digest."]
    #[doc = ""]
    #[doc = " @param[in]  hash_len Length of the digest."]
    #[doc = ""]
    #[doc = " @param[out] sig      Buffer where to store the signature."]
    #[doc = ""]
    #[doc = " @param[in]  sig_len  Length of the signature."]
    #[doc = ""]
    #[doc = " @return              Error code:"]
    #[doc = "                      - CX_OK on success"]
    #[doc = "                      - CX_EC_INVALID_CURVE"]
    #[doc = "                      - CX_INVALID_PARAMETER"]
    #[doc = "                      - INVALID_PARAMETER"]
    #[doc = "                      - CX_NOT_UNLOCKED"]
    #[doc = "                      - CX_INVALID_PARAMETER_SIZE"]
    #[doc = "                      - CX_MEMORY_FULL"]
    #[doc = "                      - CX_NOT_LOCKED"]
    #[doc = "                      - CX_INVALID_PARAMETER_SIZE"]
    #[doc = "                      - CX_EC_INVALID_POINT"]
    #[doc = "                      - CX_EC_INFINITE_POINT"]
    #[doc = "                      - CX_INTERNAL_ERROR"]
    #[doc = "                      - CX_INVALID_PARAMETER_VALUE"]
    pub fn cx_eddsa_sign_no_throw(
        pvkey: *const cx_ecfp_private_key_t,
        hashID: cx_md_t,
        hash: *const u8,
        hash_len: size_t,
        sig: *mut u8,
        sig_len: size_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Verify a signature."]
    #[doc = ""]
    #[doc = " @details Verify a signature according to the specification"]
    #[doc = "          <a href=\"https://tools.ietf.org/html/rfc8032\"> RFC8032 </a>."]
    #[doc = ""]
    #[doc = " @param[in]  pukey    Public key."]
    #[doc = "                      This shall be initialized with #cx_ecfp_init_public_key_no_throw."]
    #[doc = ""]
    #[doc = " @param[in]  hashID   Message digest agorithm identifier."]
    #[doc = "                      Algorithms supported:"]
    #[doc = "                        - SHA512"]
    #[doc = "                        - SHA3"]
    #[doc = "                        - Keccak"]
    #[doc = ""]
    #[doc = " @param[in]  hash     Pointer to the message digest."]
    #[doc = ""]
    #[doc = " @param[in]  hash_len Length of the digest."]
    #[doc = ""]
    #[doc = " @param[out] sig      Pointer to the signature."]
    #[doc = ""]
    #[doc = " @param[in]  sig_len  Length of the signature."]
    #[doc = ""]
    #[doc = " @return              1 if the signature is verified, otherwise 0."]
    pub fn cx_eddsa_verify_no_throw(
        pukey: *const cx_ecfp_public_key_t,
        hashID: cx_md_t,
        hash: *const u8,
        hash_len: size_t,
        sig: *const u8,
        sig_len: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief   Encode the curve point coordinates."]
    #[doc = ""]
    #[doc = " @param[in] coord A pointer to the point coordinates in the form x|y."]
    #[doc = ""]
    #[doc = " @param[in] len   Length of the coordinates."]
    #[doc = ""]
    #[doc = " @param[in] sign  Sign of the x-coordinate."]
    #[doc = ""]
    pub fn cx_encode_coord(coord: *mut u8, len: cty::c_int, sign: cty::c_int);
}
extern "C" {
    #[doc = " @brief   Decode the curve point coordinates."]
    #[doc = ""]
    #[doc = " @param[in] coord A pointer to the point encoded coordinates."]
    #[doc = ""]
    #[doc = " @param[in] len   Length of the encoded coordinates."]
    #[doc = ""]
    #[doc = " @return Sign of the x-coordinate."]
    pub fn cx_decode_coord(coord: *mut u8, len: cty::c_int) -> cty::c_int;
}
